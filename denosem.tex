\section{Denotational Semantics for Frank}
\label{sec:denote}

The prototype interpreter contains an evaluator implementing a denotational
semantics operating on untyped Frank programs. The interpretation function
$\sem{\cdot}$ interprets Frank programs (\textbf{Syn}) in an ML-like meta
language represented by the semantic domain \textbf{Comp}. \textbf{Comp} is a
monad (\textbf{CommandMonad} or \textbf{CM})
over a collection of primitive values as defined in
Figure~\ref{fig:eval-comp}. Booleans and integers are ranged over by $b$ and
$i$, respectively. Constructors in Frank are encoded as $k~\many{v}$ where
$k$ ranges over strings (considered builtins to the meta language). $h$ ranges
over function spaces
$\text{\textbf{Comp}}^n \longrightarrow \text{\textbf{Comp}}$,
$\forall n \in \NN$. Commands are represented by $c~\many{v}~r$
where $c$ ranges over strings and $r$ ranges over function spaces
$\text{\textbf{Value}} \longrightarrow \text{\textbf{Comp}}$.
The interpretation function is defined in Figure~\ref{fig:frank-deno-sem}.

Every Frank
program must have a \verb!main!  function which is called by the evaluator
after populating the environment with builtins and the (potentially) mutually
recursive top-level function definitions.

described by an untyped
evaluator which performs the handling of the effects by monadicly threading
computations through the thing

we have a compiler that is structured like parser then typechecker
then untyped evaluator the untyped evaluator does things on a
mid-level language that has be desugared somewhat

I have some vague notion of what i want here a monadic presentation of the
denotational semantics everything is a value the operations push unhandled
computations up the tree and a final value is returned make a point of
mentioning that this is with the full frank type system and so works for
multi-handlers not just unary handlers

some questions: how does this compare to ``traditional'' denotational
semantics? i.e. is it usually monadic? Is the monadic aspect even that
original/novel/noteworthy?

a figure describing for each construct its interpretation function with
suitable notation

denotation of contexts/environments
denotation of terms: values and computations
anything else?

\begin{figure}[float]
\begin{syntax}
\slab{\textbf{Value}}& v &::=& b \mid i \mid k~\many{v} \mid h\\
\slab{\textbf{CommandMonad}}& m~a &::=& a \mid c~\many{a}~r\\
\slab{\textbf{Comp}}&  e &::=& m~v
\end{syntax}
\caption{Semantic Domains}
\label{fig:eval-comp}
\end{figure}

\begin{figure}[float]
Monadic Operations
\begin{seqdef}
seq :& \textbf{[Comp]} & \longrightarrow & \textbf{CM [Value]} & \\
seq  & []        &=& [] & \\
seq  & m  :: ms  &=& \begin{array}{ll}
                       \text{do} & x \leftarrow m\\
                                 & xs \leftarrow ms\\
                                 & x :: xs
                     \end{array}
\end{seqdef}
Terms
\begin{syntax}
\slab{inter. function}& \sem{\cdots} &:& \textbf{Syn} \longrightarrow
 \textbf{Env} \longrightarrow \textbf{Comp}\\
\slab{variable lookup}& \deno{x}              &::=& \rho(x) \\
\slab{command lookup}&  \deno{c}              &::=&
  \lambda~\many{e}.\text{do}~\many{v} \leftarrow \text{seq}~\many{e} \seq
                             c~\many{v}~(\lambda~v.v) \\
\slab{constructor}&   \deno{k~\many{v}} &::=& k~\many{\deno{v}}\\
\slab{thunked value}& \deno{\thunk{v}} &::=& \lambda (). \deno{v}\\
\slab{thunked clauses}& \deno{\thunk{\many{\many{r} \to e}}} &::=&
  \lambda cs. \deno{e}\\
\slab{handler application}& \deno{d~\many{e}} &::=&
  \text{let}~f = \deno{d}~\text{in} f~\many{\deno{e}}\\
\end{syntax}

\caption{Frank Denotational Semantics}
\label{fig:frank-deno-sem}
\end{figure}

%%  LocalWords:  Lindley Conor Strathclyde Plotkin Pretnar's Multi et
%%  LocalWords:  effectful modularity polymorphism Kammar al Pretnar
%%  LocalWords:  Hindley Milner Oury SML Haskell monadic Kiselyov DSL
%%  LocalWords:  Idris Brady's equational multi unary al's datatypes
%%  LocalWords:  datatype Vn typecheck Ri catter polytypes inferable
%%  LocalWords:  checkable letrec monomorphic reifying desugars ret
%%  LocalWords:  homomorphic monothunks reified pre rewrapped monads
%%  LocalWords:  denotationally Swierstra Visscher Filinski Daan Koka
%%  LocalWords:  Filinski's Leijen's Swamy monad
