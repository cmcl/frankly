\section{Denotational Semantics for Frank}
\label{sec:denote}

The prototype interpreter contains an evaluator implementing a denotational
semantics operating on untyped Frank programs. The denotational semantics is
described formally in Figure~\ref{fig:frank-deno-sem}. The interpretation
function $\sem{\cdot}$ takes syntactic constructs in Frank to the domain of
computations and values. Every Frank program must have a \verb!main! function
which is called by the evaluator after populating the environment with
builtins and the (potentially) mutually recursive top-level function
definitions.

described by an untyped
evaluator which performs the handling of the effects by monadicly threading
computations through the thing

we have a compiler that is structured like parser then typechecker
then untyped evaluator the untyped evaluator does things on a
mid-level language that has be desugared somewhat

I have some vague notion of what i want here a monadic presentation of the
denotational semantics everything is a value the operations push unhandled
computations up the tree and a final value is returned make a point of
mentioning that this is with the full frank type system and so works for
multi-handlers not just unary handlers

some questions: how does this compare to ``traditional'' denotational
semantics? i.e. is it usually monadic? Is the monadic aspect even that
original/novel/noteworthy?

a figure describing for each construct its interpretation function with
suitable notation

denotation of contexts/environments
denotation of terms: values and computations
anything else?

\begin{figure}[float]
Terms
\begin{syntax}
\slab{inter. function}& \sem{\cdots} &:& \textbf{Syn} \longrightarrow
 \textbf{Env} \longrightarrow \textbf{Comp} \\
\slab{variable lookup}& \deno{x}              &::=& \rho(x) \\
\slab{command lookup}&  \deno{c}              &::=& \ldots \\
\slab{handler application}& \deno{d~\many{e}} &::=& \text{let}~f = \deno{d}~\text{in} f~\many{\deno{e}}
\end{syntax}

\caption{Frank Denotational Semantics}
\label{fig:frank-deno-sem}
\end{figure}

%%  LocalWords:  Lindley Conor Strathclyde Plotkin Pretnar's Multi et
%%  LocalWords:  effectful modularity polymorphism Kammar al Pretnar
%%  LocalWords:  Hindley Milner Oury SML Haskell monadic Kiselyov DSL
%%  LocalWords:  Idris Brady's equational multi unary al's datatypes
%%  LocalWords:  datatype Vn typecheck Ri catter polytypes inferable
%%  LocalWords:  checkable letrec monomorphic reifying desugars ret
%%  LocalWords:  homomorphic monothunks reified pre rewrapped monads
%%  LocalWords:  denotationally Swierstra Visscher Filinski Daan Koka
%%  LocalWords:  Filinski's Leijen's Swamy monad
