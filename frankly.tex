\documentclass[preprint]{sigplanconf}

% US Letter page size
%\pdfpagewidth=8.5in
%\pdfpageheight=11in


% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{url}

\usepackage{MnSymbol}

\newcommand{\lameff}{$\lambda_\mathrm{eff}$\xspace}
\newcommand{\feff}{$F_\textrm{eff}$\xspace}
\newcommand{\impeff}{Implicit \lameff}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\many}{\overline}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}

\newcommand{\seml}{\left\llbracket}
\newcommand{\semr}{\right\rrbracket}

\newcommand{\pc}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}

\newcommand{\reducesto}{\longrightarrow}

\newcommand\ba{\begin{array}}
\newcommand\ea{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newcommand{\bstack}{\begin{array}[t]{@{}l@{}}}
\newcommand{\estack}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
%% \newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newenvironment{syntax}{\[\ba{@{}l@{~}r@{~}c@{~}l@{}}}{\ea\]}


\newcommand{\judgeword}[1]{~\mathbf{#1}~}

%\renewcommand{\sig}{\Sigma}
%\renewcommand{\sigs}{\Sigma s}
\newcommand{\sigentails}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\text{-\!-}}\,}

%% \newcommand{\sigmodels}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\mathord{=}}\,}
% \newcommand{\sigentails}[1]{\vdash_{#1}}

\newcommand{\val}[3]  {#1 \vdash {#2} : {#3}}
\newcommand{\comp}[4]  {#1 \sigentails{#2} {#3} : {#4}}

\newcommand{\rt}[1]{\langle{#1}\rangle}   % returner type

\newcommand{\valg}{\val{\Gamma}}
\newcommand{\compgs}{\comp{\Gamma}{\sigs}}

%% \newcommand{\is}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
%% \newcommand{\isgs}{\is{\Gamma}{\sigs}}

%% \newcommand{\cdoes}[4]{#1 \sigentails{#2} {#3} \judgeword{has} {#4}
%% \newcommand{\cdoesgs}{\cdoes{\Gamma}{\sigs}}


\newcommand{\makes}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\has}[4] {#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\can}[4]{#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\does}[3]{#1 \vdash {#2} \judgeword{has} {#3}}

\newcommand{\effs}[2]{{#1} \judgeword{does} {#2}}

\newcommand{\pat}[3]{{#1} \judgeword{matches} {#2} \dashv #3}
\newcommand{\patg}[2]{\pat{#1}{#2}{\Gamma}}

\newcommand{\makesgs}{\makes{\Gamma}{\sigs}}
\newcommand{\hasgs}{\has{\Gamma}{\sigs}}
\newcommand{\cangs}{\can{\Gamma}{\sigs}}
\newcommand{\doesg}{\does{\Gamma}}


% Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\sig}{S}
\newcommand{\sigs}{\Sigma}

%% \newcommand{\sig}{\Sigma}
%% \newcommand{\sigs}{E}


%% \newcommand{\X}{X}  % a type variable

%% \newcommand{\E}{E}  % the effect variable

%% \newcommand{\U}{U}
%% \newcommand{\V}{V}
%% \newcommand{\Us}{\many{\U}}
%% \newcommand{\Vs}{\many{\V}}

%% \newcommand{\C}{C}

%% \newcommand{\tm}{t}
%% \newcommand{\tu}{u}
%% \newcommand{\tms}{\many{\tm}}
%% \newcommand{\tus}{\many{\tu}}

%% \newcommand{\p}{p}
%% \newcommand{\ps}{\many{\p}}

%% \newcommand{\h}{h}

%% \newcommand{\op}{\mathit{op}}

\newcommand{\effbox}[1]{[#1]}
%% \newcommand{\ret}[2]{\effbox{#1}{#2}}
%% \newcommand{\template}[3]{{#1} \mathbin{\effbox{#2}} {#3}}

\newcommand{\key}[1]{\mathsf{#1}}
\newcommand{\var}{\mathit}

\newcommand{\handleSymbol}{\mathbin{?}}
%% \newcommand{\yieldSymbol}{\mathbin{\prec}}
%% \newcommand{\continueSymbol}{\mathbin{\triangleleft}}
%% \newcommand{\handleType}[3]{\effbox{{#1} \yieldSymbol \ret{#2}{#3}}}
%% \newcommand{\handleTypePoly}[2]{\effbox{{#1} \yieldSymbol #2}}
%% \newcommand{\handleRet}[1]{\effbox{#1}}
%% \newcommand{\handleOp}[2]{\effbox{{#1} \continueSymbol {#2}}}
\newcommand{\handle}[2]{{#1} \handleSymbol {#2}}

%% \newcommand{\handleGen}[2]{\key{handle}~{#1}~\key{with}~{#2}}

\newcommand{\thunk}[1]{\{{#1}\}}
%\newcommand{\athunk}[2]{\thunk{#1}_{#2}}
%% \newcommand{\athunk}[2]{[#2]\thunk{#1}}

\newcommand{\force}[1]{{#1}!}
%% \newcommand{\app}{\mathbin{\text{@}}}

%% \newcommand{\con}{K}
%% \newcommand{\D}{D}

%% \newcommand{\args}{\mathit{args}}

%% \newcommand{\rplus}{\mathbin{\mathord{+}\!\!\!\!\mathord{\shortrightarrow}}}
%% \newcommand{\lplus}{\mathbin{\mathord{+}\!\!\!\!\!\mathord{\shortleftarrow}}}


%% \newcommand{\VV}{\mathbb{V}}
%% \newcommand{\VVs}{\many{\VV}}
%% \newcommand{\CC}{\mathbb{C}}

%% \newcommand{\inst}[2]{\mathit{inst}({#1}, {#2})}
%% \newcommand{\instt}[1]{\inst{\theta}{#1}}

%% \newcommand{\oldinst}[3]{\mathit{inst}({#1},{#2},{#3})}
%% \newcommand{\oldinstts}[1]{\oldinst{\theta}{\sigs}{#1}}

%% \newcommand{\appsig}[2]{{#1}\mathord{\cdot}{#2}}


\newcommand\slab[1]{(\textrm{#1})}


\begin{document}

%% \conferenceinfo{WXYZ '05}{date, City.} 
%% \copyrightyear{2005} 
%% \copyrightdata{[to be supplied]} 

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Do Be Do Be Do}
%% \subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}
           {The University of Edinburgh}
           {}
\authorinfo{Conor McBride}
           {University of Strathclyde}
           {}
%%         {Email1}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle

%% Structure:

%%   Introduction
%%   Examples
%%     parsing
%%     pipes
%%     ...
%%   Frank syntax and type system (source language)
%%     semantics by elaboration into successively simpler languages
%%   pattern matching compilation
%%     option to expose incomplete/ambiguous pattern matching as
%%     concrete effects
%%   CBPV
%%   Explicit polymorphism
%%   Small-step semantics (see handlers in action)
%%
%%   Related work
%%
%%     Plotkin+Power, Plotkin+Pretnar, Hancock, Eff, Brady, Kiselyov
%%     et al, Felleisen, Kammar et al, Filinski, Koka, Ahmen+Plotkin,
%%     Staton, Kleisli arrows of outrageous fortune, data types a la carte
%%
%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules

\begin{abstract}
We explore the design of Frank, a strict functional programming
language designed from the ground up around a novel variant of Plotkin
and Pretnar's \emph{effect handler} abstraction.
%
Inspired by Levy's call-by-push-value calculus, Frank makes an
explicit distinction between computation and value types. Frank
combines the advantages of call-by-push-value, call-by-value, and
effect typing.

%% Effect handlers in Frank generalise functions. An effect handler acts
%% as an interpreter for a specified set of commands whose signatures are
%% statically tracked by the type system. A function is the special case
%% of an effect handler whose command set is empty.
\end{abstract}

%% keywords
%%
%% algebraic effects
%% effect handlers
%% effect polymorphism
%% call-by-push-value
%% pattern matching
%% continuations

\section{Introduction}

% TODO: more background on algebraic effects and handlers?

Plotkin and Power's algebraic effects~\cite{PlotkinP01a, PlotkinP01b,
  PlotkinP02, PlotkinP03}, in conjunction with Plotkin and Pretnar's
handlers for algebraic effects~\cite{PlotkinP09, PlotkinP13}, provide
a compelling foundation for effectful programming.
%
By separating effect signatures from their implementation, algebraic
effects provide a high degree of modularity, allowing programmers to
express effectful programs independently of the concrete
interpretation of their effects. A handler is an interpretation of the
effects of an algebraic computation.

%% This paper explores the design of Frank, a strict functional
%% programming language designed from the ground up around a novel
%% variant of Plotkin and Pretnar's \emph{effect
%%   handler}~\cite{PlotkinP09, PlotkinP13} abstraction.

%% Inspired by Levy's call-by-push-value calculus~\cite{Levy2004}, Frank
%% makes an explicit distinction between computation and value
%% types. Frank combines the advantages of call-by-push-value,
%% call-by-value, and effect typing.

Effect handlers in Frank generalise functions. An effect handler acts
as an interpreter for a specified set of commands whose signatures are
statically tracked by the type system. A function is the special case
of an effect handler whose command set is empty.

The contributions of this paper are:
\begin{itemize}
\item Frank, a strict functional programming language featuring a
  bidirectional effect type system, effect polymorphism, and effect
  handlers.
\item A novel approach to effect polymorphism which avoids all mention
  of effect variables, crucially relying on the observation that one
  must always instantiate the effects of a function being applied with
  the current \emph{ambient} effects.
\item The combination of pattern matching and effect handlers in such
  a way that incomplete or ambiguous pattern matching can be realised
  as concrete effects that can be handled however the programmer
  chooses using further effect handlers.
\item Multi-handlers as both an abstraction for handling multiple
  computations over different effect sets simultaneously and a
  characterisation of effect-handlers as generalised functions.
\item A description of pattern matching compilation from Frank into a
  core language, \emph{Core Frank}.
\item A translation from Core Frank into \feff, a polymorphic variant
  of the \lameff calculus of Kammar et al~\cite{KammarLO13}, which in
  turn extends Levy's call-by-push-value calculus~\cite{Levy2004}.
\item A straightforward small-step operational semantics for \feff,
  yielding, in combination with the translation to \feff, a type
  soundness result for Frank.
\end{itemize}

A number of other languages and libraries are built around effect
handlers and algebraic effects.

Bauer and Pretnar's Eff~\cite{BauerP12}. A significant difference
between Frank and the original version of Eff~\cite{BauerP12} is that
the latter provides no support for effect typing. Recently Bauer and
Pretnar have designed an effect type system for
Eff~\cite{BauerP13}. Their implementation~\cite{Pretnar13} supports
Hindley-Milner type inference, and the type system incorporates effect
sub-typing. In contrast, Frank uses bidirectional type inference, and
avoids sub-typing altogether.

Handlers in action~\cite{KammarLO13}. In previous work with Kammar and
Oury~\cite{KammarLO13}, the first author designed and experimented
with a number of effect handler libraries for languages ranging from
Racket, to SML, to Haskell. Apart from the Haskell library, these
other libraries have no effect typing support. The Haskell library
takes advantage of type classes to simulate an effect type system not
entirely dissimilar to that of Frank. As Haskell is lazy, the Haskell
library cannot be used to write direct-style effectful programs - one
must instead adopt a monadic style. Furthermore, although there are a
number of ways of almost simulating effect type systems in Haskell,
none is without its flaws. Kiselyov et al~\cite{KiselyovSS13} have
designed another Haskell library for effect handlers, making a
different collection of design choices.

Brady~\cite{Brady13} has designed a library and DSL for programming
with effects in his dependently typed Idris language. Like the Haskell
libraries, Brady's library currently requires the programmer to write
effectful code in a monadic style.

In Plotkin and Powerâ€™s setting, one defines algebraic effects with
respect to an equational theory. In all of the above implementations,
and in Frank, the equational theory is taken to be the free theory, in
which there are no equations.
%

The second author has been plotting Frank since
2007~\cite{McBride07}. He has implemented a prototype of a previous
version of Frank~\cite{McBride12}. The design described in the current
paper has much in common with that implementation, but there are some
syntactic and semantic differences. The most important change in the
current design is the introduction of multi-handlers as a
generalisation of both functions and handlers.

The rest of the paper is structured as follows.
%
Section~\ref{sec:examples} introduces Frank by
example. Section~\ref{sec:frank} presents a type system for
Frank. Section~\ref{sec:core} describes how to elaborate
multi-handlers and pattern matching into Core Frank, a language of
plain call-by-value functions, explicit case analysis and unary
handler constructs. Section~\ref{sec:feff} gives a call-by-value
embedding of Core Frank into \feff, a variant of Kammar et al's
\lameff calculus with shallow handlers, explicit polymorphism and
general recursion. Section~\ref{sec:semantics} gives a semantics for
\feff, which when composed with pattern matching and the call-by-value
embedding, yields a semantics for Frank. Section~\ref{sec:related}
outlines related work and Section~\ref{sec:future} discusses future
work.

\section{Introducing Frank}
\label{sec:examples}

Frank is a functional programming language with effects and handlers
in the style of Eff controlled by a type system inspired by Levy's
call-by-push-value~\cite{Levy2004}.
%
Doing and Being are clearly separated, and managed by distinguished
notions of computation and value types.

Concrete values live in inductive datatypes.
%
\begin{verbatim}
data List X
   = nil
   | cons X (List X)

data Zero =

data Unit = unit
\end{verbatim}

We can write perfectly ordinary functional programs, with (compulsory)
type signatures.
%
\begin{verbatim}
append : List X -> List X -> List X
append nil       ys = ys
append (x :: xs) ys = cons x (append xs ys)
\end{verbatim}

Higher-order functions are passed suspended computations. Braces are
"suspenders".
%
\begin{verbatim}
map {X -> Y} -> List X -> List Y
map f nil         = nil
map f (cons x xs) = cons (f x) (map f xs)
\end{verbatim}

A value type \verb!V! is a datatype \verb!D V1 ... Vn!, a suspended
computation type \verb!{C}!, or a type variable \verb!X!.
%
A computation type can be a function type \verb!V -> C! or an
effect-annotated value type \verb![S1 ... Sn]V!, where an empty
bracket may be omitted.

Effects are collections of signatures, which describe a choice of
commands. Here are some simple signatures.
%
\begin{verbatim}
sig Send X
  = send : Unit(X)

sig Receive X
  = receive : X

sig Abort
  = aborting : Zero
\end{verbatim}
%
The \verb!send! command takes an argument of type \verb!X! and returns
a value of type \verb!Unit!. The \verb!receive! command returns a
value of type \verb!X!. The abort command returns an element of the
empty type, \verb!Zero!.

Frank is a call-by-value language, but it naturally distinguishes
\verb![]V!, the type of suspended pure computations which deliver a
\verb!V!, from \verb!V! itself. We can thus define a kind of
"semicolon" just as the function which ignores its first argument.
%
\begin{verbatim}
semi : X Y -> Y
semi x y = y
\end{verbatim}

Frank has effect polymorphism, enough to allow higher-order functions
to pass effect permissions to their parameters. The following uses map
to send a list of things, one at a time.
%
\begin{verbatim}
sends : List X -> [Send X]Unit
sends xs = semi (map send xs) unit
\end{verbatim}
%
The reason this type checks at all is because \verb!map! is implicitly
polymorphic in its effects.

The following does not typecheck, because the \verb!Send! effect is
not permitted in the return type of \verb!bad!.

\begin{verbatim}
bad List X -> Unit
bad xs = semi (map send xs) unit
\end{verbatim}

Writing control operators is not too tricky.
\begin{verbatim}
bind : X -> {X -> Y} -> Y
bind x f = f x
\end{verbatim}

We can use \verb!bind! to define a polymorphic \verb!abort! function.
\begin{verbatim}
abort : [Abort]X
abort = bind aborting! {}
\end{verbatim}
The term \verb!{}! denotes a suspended computation containing an empty
collection of pattern matching clauses covering the \verb!Zero! return
type of \verb!aborting!.

Here is a computation which receives and concatenates lists until one
is empty.
%
\begin{verbatim}
catter : [Receive (List X)]List X
catter = bind receive!
           { nil -> nil
           | xs  -> append xs catter!
           }
\end{verbatim}
%
The command \verb!receive! is a suspended computation of type
\verb!{[Receive (List X)]List X}! that delivers a list when
forced. The notation \verb|receive!| forces a thunk.

If \verb!f! is a suspended computation of function type, then
\verb!f x! is syntactic sugar for \verb|f! x|. Thus we need only
explicitly force computations that take no arguments.

Effects are handled by special functions called \emph{effect
  handlers}. Effect handlers in Frank can take multiple computations
as arguments, hence they are \emph{multi-handlers}. In fact standard
functions like the ones we have seen so far are just special cases of
multi-handlers in which the all the arguments are pure.

A multi-handler has type \verb!R1 -> ... -> Rm -> R! where each
\verb!Ri! and \verb!R! is an effect-annotated value type. For
instance, we can write a \verb!pipe! multi-handler which handles
\verb!send! commands from one computation by matching them against
corresponding \verb!receive! commands from another.
%
\begin{verbatim}
pipe : [Send X]Unit -> [Receive X]Y -> [Abort]Y
pipe _            y             = y
pipe unit         _             = abort!
pipe (send x ? s) (receive ? r) =
  pipe (s unit) (r x)
\end{verbatim}
%
The type signature conveys several different things. The \verb!pipe!
  handler must handle all \verb!Send X! commands in its first argument
  and all \verb!Receive X! commands in its second argument. The first
  argument returns values of type \verb!Unit! and the second argument
  returns values of type \verb!Y!. The handler itself is allowed to
  perform \verb!Abort!  commands and returns a final value of type
  \verb!Y!.

Here are some things to send.
\begin{verbatim}
hello : List Char
hello =
  cons 'h' (cons 'e' (cons 'l'
    (cons 'l' (cons 'o' nil))))

space : List Char
space = cons ' ' nil

world : List Char
world =
  cons 'w' (cons 'o' (cons 'r'
    (cons 'l' (cons 'd' nil))))
\end{verbatim}
%
Here is a computation which sends them.
%
\begin{verbatim}
sender : [Send (List Char)]Unit
sender =
  sends (cons (hello
           (cons space (cons world nil))))
\end{verbatim}

Here is a \verb!main! function, which plugs \verb!sender! and
\verb!catter!  together and sends their output to the console.
%
\begin{verbatim}
main : [Abort, Console](List Unit)
main = map ouch (pipe sender catter)
\end{verbatim}
where the \verb!Console! operations are handled specially at the
top-level according to the following signature.
\begin{verbatim}
sig Console
  = inch : Char(Unit)
  | ouch : Unit(Char)
\end{verbatim}

The type system does two separate things:
\begin{itemize}
\item It ensures that value types coincide.
\item It ensures that effects required are included in effects
  enabled.
\end{itemize}

The fun of Frank is that one can say what it is to \emph{be} a
computation without saying what it is to \emph{do} it. Doing and being
are separately negotiable, and readily interleaved in different
ways. Or as Frank Sinatra put it,
\begin{center}
do be do be do
\end{center}

%% TODO: some illustration of forwarding?

%% \subsection{Modular rollback}

%% TODO: probably scrap this section

%% \subsection{Effect polymorphism with an invisible effect variable}

%% TODO: move this discussion after the type system for Frank has been
%% introduced

%% Let us consider the canonical example of a polymorphic higher-order
%% function \verb|map|.
%% \begin{verbatim}
%% data List X = nil | cons X (List X)

%% map : (X -> Y) -> List X -> List Y
%% map f nil         = nil
%% map f (cons x xs) = cons (f x) (map f xs)
%% \end{verbatim}
%% The type we have given to map is the standard one a functional
%% programmer might expect to write in a language without support for
%% effect typing.
%% %
%% Though it looks polymorphic



%% %
%% We automatically translate it into a valid Frank type by applying a
%% series of desugaring rules.

%% The valid Frank type we are after is:
%% \begin{verbatim}
%% forall e X Y.{[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)}
%% \end{verbatim}

%% First, for readability we allow the signature for recursively defined
%% functions to be defined on a separate line, as in Haskell.
%% %
%% Second, we allow the quantifiers to be omitted, just like in Haskell.
%% \begin{verbatim}
%% {[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)}
%% \end{verbatim}
%% Third, we allow the outer braces to be omitted, as the type must always be a thunk.
%% \begin{verbatim}
%% [0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)
%% \end{verbatim}

%% %% S~\many{V} == 0, S~\many{V}
%% %% S~\many{V} == e, S~\many{V}

%% Let us distinguish between returners $\effbox{\sigs}V$ in argument
%% position, whose effects $\sigs$ must be closed, and those in tail
%% position, whose effects need not be closed. We call the former
%% \emph{ports}, and the latter \emph{pegs}.

%% Now we take advantage of some more general desugaring rules.
%% \begin{equations}
%%                       V &\equiv& \effbox{\varepsilon}V \\
%%                 V \to C &\equiv& \effbox{\emptyset}V \to C \\
%% \effbox{\sigs}(R \to C) &\equiv& \effbox{\sigs}\thunk{R \to C} \\
%% \end{equations}
%% where the first rule is restricted to pegs (it would be nonsensical
%% for ports anyway, as their effects must always be closed).

%% The first rule is the critical one. It allows us to avoid writing down
%% the effect variable. The second rule makes sense as ports being closed
%% means that writing down $\emptyset$ is redundant. The third rule is
%% superficial.

%% Applying each rule in turn we obtain:
%% \begin{verbatim}
%% [0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)
%% [0]([0]X -> [e]Y) -> [0](List X) -> [e](List Y)
%% [0]([0]X ->    Y) -> [0](List X) ->     List Y 
%%    (   X ->    Y) ->     List X  ->     List Y 
%% \end{verbatim}

%% In order to account for non-empty effect sets, we also apply the
%% following rules:
%% \begin{equations}
%% S~\many{V} &\equiv& \varepsilon, S~\many{V} \\
%% S~\many{V} &\equiv& \emptyset, S~\many{V} \\
%% \end{equations}
%% where the first only applies to peg effect sets, and the second only
%% applies to port effect sets.

%% For instance:
%% \[
%% \bstack
%% \thunk{\effbox{\var{Abort}}\var{Int} \to \effbox{\var{State}~\var{Int}}\var{Bool}} \to \var{Int}
%% \equiv \\
%%   \qquad \thunk{\effbox{\emptyset, \var{Abort}}\var{Int} \to
%%        \effbox{\varepsilon, \var{State}~\var{Int}}\var{Bool}} \to \effbox{\varepsilon}\var{Int}
%% \estack
%% \]

%% With the syntactic sugar in place, we can now avoid writing the effect
%% variable $\varepsilon$ ever. In addition, we need never write
%% $\emptyset$ in port effect sets. It is sometimes necessary to
%% explicitly write $\emptyset$ in peg effect sets. In particular, a pure
%% top-level program returning values of type $V$ has type
%% $\effbox{\emptyset}V$.





\section{Type System}
\label{sec:frank}

In this section we give a formal presentation of Frank's type system.
%
\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V          &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C             &::=& R \mid R \to C \\
\slab{returners}    &R             &::=& \effbox{\sigs}V
\\[1ex]
\slab{quantifiers}  &Z             &::=& X \mid \varepsilon \\
\slab{polytypes}    &P             &::=& \forall \many{Z}.Q \\
\slab{thunks}       &Q             &::=& \thunk{C}
\\[1ex]
\slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma        &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

Terms
\begin{syntax}
\slab{inferable values}&u       &::=& x \mid f \mid d                                \\
\slab{checkable values}&v        &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferable computations}&d &::=& \force{u} \mid d~e \mid c
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checkable computations} &e &::=& v \mid \many{r} \mapsto e \mid () \mid e \medvert e
\\[1ex]
\slab{value patterns}&p       &::=& x \mid k~\many{p}                              \\
\slab{computation patterns}&r &::=& p \mid \handle{c~\many{p}\,}{g} \mid \force{x} \\
\end{syntax}

\caption{Frank Syntax}
\label{fig:frank-syntax}
\end{figure}
%
The syntax of Frank types and terms is given in
Figure~\ref{fig:frank-syntax}. The types are divided into value types
and computation types in a similar fashion to Levy's
call-by-push-value calculus~\cite{Levy2004}.
%
Value types are datatypes ($D~\many{U}$), suspended $C$ computations
($\thunk{C}$), otherwise known as \emph{thunks}, or type variables
($X$).

Computation types are constructed from \emph{returners}.  A returner
$(\effbox{\sigs}V)$ represents the type of a computation that returns
values of type $V$ while performing effects in $\sigs$.
%
In general, computation types represent multi-handlers. The type
$\effbox{\sigs_1}V_1 \to \dots \to \effbox{\sigs_n}V_n \to
\effbox{\sigs}V$,
%
is the type of an $n$-handler. For each argument type
$\effbox{\sigs_i}V_i$ the multi-handler must handle effects in
$\sigs_i$ on that argument. Such an $n$-handler handles all of its
arguments simultaneously. As a result of handling its arguments it
returns a value of type $V$ and may perform effects in $\sigs$.
%
We often write $\many{\effbox{\sigs}V} \to C$ as an abbreviation for
$\effbox{\sigs_1}V_1 \to \dots \to \effbox{\sigs_n}V_n \to C$.

Polytypes are restricted to thunks. Effect polymorphism is restricted
to a single effect variable $\varepsilon$, which in practice Frank
programmers need never write.

Datatypes and effect signatures are declared at the top-level. An
effect signature $S~\many{X}$ consists of a collection of command
declarations of the form $c:U(\many{V})$, denoting that command $c$
takes arguments of types $\many{V}$ and returns a value of type
$U$. The types $\many{V}$ and $U$ may all depend on $\many{X}$. Each
command many appear only once in a signature, and each command may
appear in only one signature.

An effect set is a sequence of signatures initiated either with the
empty effect $\emptyset$ (yielding a \emph{closed effect set}) or the
only effect variable $\varepsilon$ (yielding an \emph{open effect
  set}). Order is important, as repeats are permitted, in which case
the right-most signature overrides all others with the same name.

Shadowing arises naturally in two ways. First, given an open effect
set $\sigs$ we may substitute an arbitrary effect set for
$\varepsilon$. Second, we define a notion of effect extension: $\sigs
\oplus \sigs'$ is the \emph{extension} of effect set $\sigs$ with
closed effect set $\sigs'$, formally:
%
\[\ba{@{\sigs~\oplus~}l@{~}l@{}}
\emptyset               &= \sigs \\
(\sigs', \sig~\many{V}) &= (\sigs \oplus \sigs'), \sig~\many{V} \\
\ea\]

Type environments distinguish monomorphic and polymorphic variables.

Just as with the types, Frank terms are separated into value terms and
computation terms. With future extensions, such as dependent types, in
mind, Frank adopts a bidirectional typing
discipline~\cite{PierceT00}. Thus terms are further sub-divided into
those whose type is inferable, and those that may be checked against a
type.

Frank is less strict about the separation between value and
computation terms than call-by-push-value is. For instance, inferable
computations can sometimes be treated as inferable values. This is a
deliberate design decision, with the aim of making Frank convenient to
program with.

%%%%% Frank

\begin{figure*}[float]
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{R \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \many{Z}.Q \in \Gamma \\
   \dom(\theta) = \set{\many{Z}} \\
   \varepsilon \in \dom(\theta) \implies \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(Q)}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{U} \\ U = V}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{C}{e} \\ e \text{ is complete for } C}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \doesg{\effbox{\sigs \oplus \sigs'}V}{e}}
  {\can{\Gamma}{\sigs}{d~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs}
  {\cangs{c}{\many{\effbox{}V} \to \effbox{\sigs}U}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\does{\Gamma, \many{f : \forall \many{Z}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\doesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesg{\effbox{\sigs}V}{v}}

\inferrule
  {\many{\sigs'} \text{ closed} \\
   (\pat{\effbox{\sigs'_i}V_i}{r_i}{\Delta_i})_i \\
   \does{\Gamma, \many{\Delta}}{C}{e}}
  {\doesg{\many{\effbox{\sigs'}V} \to C}{\many{r} \mapsto e}}

\inferrule
  {V \text{uninhabited}}
  {\doesg{\effbox{\sigs'}V \to C}{()}}

\inferrule
  {\doesg{R \to C}{e} \\ \doesg{R \to C}{e'}}
  {\doesg{R \to C}{e \medvert e'}}
\end{mathpar}

$\boxed{\pat{V}{p}{\Delta}}$

\begin{mathpar}
\inferrule
  { }
  {\pat{V}{x}{x:V}}

\inferrule
  {k~\many{V} \in D~\many{U} \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{D~\many{U}}{k~\many{p}}{\many{\Delta}}}
\end{mathpar}

$\boxed{\pat{R}{r}{\Delta}}$

\begin{mathpar}
\inferrule
  {\pat{V}{p}{\Delta}}
  {\pat{\effbox{\sigs}V}{p}{\Delta}}

\inferrule
  {c:U(\many{V}) \in \sigs \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{\effbox{\sigs}V}
       {\handle{c~\many{p}}{g}}
       {\many{\Delta}, g:\thunk{\effbox{\emptyset}U \to \effbox{\sigs}V}}}

\inferrule
  { }
  {\pat{\effbox{\sigs}V}{\force{x}}{x:\thunk{\effbox{\sigs}V}}}
\end{mathpar}

\caption{Frank Typing Rules}
\label{fig:frank-typing}
\end{figure*}

The typing rules for Frank are given in Figure~\ref{fig:frank-typing}.
%
The judgement $\makesgs{u}{V}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferable value term $u$, then
we can infer that $u$ \emph{is} of type $V$.
%
The judgement $\hasgs{V}{v}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, value type $V$, and checkable
value term $v$, then we can check that $V$ \emph{has} $v$ as a valid term.
%
The judgement $\cangs{d}{C}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferable computation term $d$,
then we can infer that $d$ \emph{is} of type $C$.
%
The judgement $\doesg{C}{e}$ says that given type environment
$\Gamma$, computation type $C$, and checkable computation term $e$,
then we can check that $C$ \emph{has} $e$ as a valid computation term.

The types of monomorphic variables ($x$) are simply looked up in the
type environment. The types of polymorphic variables ($f$) are looked
up and instantiated. In practice this means applying a simple
unification-based algorithm.
%
An inferable computation ($d$) is also an inferable value, providing
it is a returner whose effects agree with the ambient effects.

Any inferable value ($u$) is also checkable against its inferred
type. Datatype ($k~\many{v}$) and thunk ($\thunk{e}$) terms are
checkable by checking their components. The side condition on the
thunk introduction rule requires that the pattern matching clauses of
$e$ be complete with respect to the type $C$ of $e$.

A thunk $u$ can by forced ($u!$) if its inferred type agrees with the
ambient effects. To infer the type of a handler application $d~e$, we
first infer the type of $d$, and then check that the argument matches
the inferred argument type. Note that the effect set on an argument
must be closed, and thus we may extend the ambient effect set with the
argument effect set when checking the argument.
%
The type of a command ($c$) is looked up from the ambient effects.
%
The term $\key{let}~x=d~\key{in}~d'$ binds the result of running $d$
in $d'$.
%
The term $\key{letrec}~\many{f : P = e}~\key{in}~d$ binds the mutually
recursive polymorphic functions $\many{f:P}$ in $d$.

Any term $v$ that type checks with ambient effects $\sigs$ at value
type $V$ also type checks at computation type $\effbox{\sigs}V$.
%
A multi-handler of type $\many{\effbox{\sigs'}V} \to C$ is built by
composing clauses of the form $\many{r} \mapsto e$, where $\many{r}$
is a sequence of \emph{computation patterns} whose variables are bound
in $e$.
%
The $e \medvert e'$ construct composes the clauses of $e$ with those
of $e'$. A multi-handler is defined by a collection of clauses that
provides complete coverage of the input types.
%
The $()$ construct allows empty sets of clauses to be constructed in
the event that the value type of a function argument is uninhabited.

We preclude composition of non-clauses (i.e. returners) by
constraining $e \medvert e'$ to have function type.
%
It is perfectly legitimate to compose clauses with different numbers
of arguments, though as a preliminary part of pattern matching
compilation, we first transform the program to ensure that all
composed clauses do have the same number of arguments.

Value patterns are standard, consisting of variable patterns ($x$) and
datatype constructor patterns ($k~\many{p}$).

Computation patterns are more interesting. Any value pattern $p$ is
also a computation pattern (used to match against the value returned
by the returner computation).
%
A request pattern $\handle{c~\many{p}}{g}$ matches against a
computation of the form $\force{c}~\many{v}$ if the values $v$ match
against $p$. Furthermore, it also binds $g$ to the continuation of the
computation delimited by the nearest enclosing multi-handler. This is
where the real power of multi-handlers arises. A thunk pattern
$\force{x}$ matches any computation reifying it as a thunk bound to
$x$.


\subsection{Effect Polymorphism with an Invisible Effect Variable}

We now give a brief description of how syntactic sugar allows Frank
programmers to omit effect variables completely.
%
Consider the type of \verb!map! in Section~\ref{sec:examples}:
\[
\thunk{X \to Y} \to \var{List~X} \to \var{List~Y}
\]
Apart from perhaps the curly braces, this looks pretty much the same
as the type a functional programmer might expect to write in a
language without support for effect typing.

In fact, this type desugars into the rather more verbose:
\[
\thunk{\effbox{\emptyset}X \to \effbox{\varepsilon}Y}
  \to \effbox{\emptyset}(\var{List~X}) \to \effbox{\varepsilon}(\var{List~Y})
\]

Let us distinguish between returners $\effbox{\sigs}V$ in argument
position, whose effects $\sigs$ must be closed, and those in tail
position, whose effects need not be closed. We call the former
\emph{ports}, and the latter \emph{pegs}.

Observe that ports are closed, so it is never necessary to write the
$\emptyset$ in their effects. Pegs, on the other hand, may be open or
closed. We adopt the convention that $\varepsilon$ may be omitted from
the start of a peg's effects. Thus, if we know it is a peg, then $V$
means $\effbox{}V$, which means $\effbox{\varepsilon}V$, and
$\effbox{\var{Abort}}V$ means $\effbox{\varepsilon, \var{Abort}}V$.

We now summarise the syntactic sugar. For ports and pegs:
\begin{equations}
V &\equiv& \effbox{}V \\
\end{equations}
For ports:
\begin{equations}
\effbox{\many{S~\many{V}}}U &\equiv& \effbox{\emptyset, \many{S~\many{V}}}U \\
\end{equations}
For pegs:
\begin{equations}
\effbox{\many{S~\many{V}}}U &\equiv& \effbox{\varepsilon, \many{S~\many{V}}}U \\
\end{equations}

With this syntactic sugar in place, we can now avoid writing the
effect variable $\varepsilon$ in Frank programs, ever. In addition, we
need never write $\emptyset$ in port effect sets. It is sometimes
necessary to explicitly write $\emptyset$ in peg effect sets. In
particular, a pure top-level program returning values of type $V$ has
type $\effbox{\emptyset}V$.

%% [already mentioned in the example section]
%%
%% Another useful piece of syntactic sugar is for function
%% application. We often write $u~e$ for $\force{u}~e$.

%% TODO: get rid of GIBBERISH




%% As is made apparent by the call-by-value translation in
%% Section~\ref{sec:feff}, Frank is morally a call-by-value language
%% (though multi-handlers complicate the picture somewhat).




%% Frank has a number of distinctive features.

%% Inspired by Levy's call-by-push-value (CBPV) calculus, Frank makes an
%% explicit distinction between computation and value types. However,
%% where CBPV also has a clear distinction between value terms and
%% computation terms, Frank is less rigid. The motivation for this design
%% is to reduce boilerplate in source programs. Frank combines the
%% advantages of CBPV, call-by-value (a la ML), and effect typing.

%% With future extensions for dependent types in mind, Frank adopts a
%% bidirectional typing discipline. A side-effect is that one cannot
%% write beta-redexes in Frank. We do not view this as a disadvantage.

%% Inspired by the observation that applying a function to a value is
%% equivalent to applying a handler to a pure computation, handlers and
%% functions are unified in Frank. Handlers are further generalised to
%% multi-handlers, which handle multiple computations simulataneously.

%% Frank provides a novel form of effect polymorphism, in which it is
%% never necessary to mention the names of effect variables.

%% We explain the semantics of Frank programs through a series of program
%% transformations.

%% First, we take a fairly standard approach to compiling away pattern
%% matching (Core Frank). As we may match simultaneously against multiple
%% side-effecting computations, we must be careful about
%% order. Optionally, we can expose non-exhaustive/incomplete pattern
%% matching as concrete effects.

%% Second, we make the distinction between values terms and computations
%% explicit, as in CBPV (\impeff).

%% Finally, we make polymorphism explicit. Our ultimate target is \feff,
%% an effect-polymorphic variant of Kammar et al's CBPV-inspired
%% lambda-eff calculus. The small-step semantics of \feff is a
%% straightforward variant of that of lambda-eff.


\section{Pattern Matching Compilation}
\label{sec:core}

We take a fairly standard approach to compiling away pattern
matching. As we may match simultaneously against multiple
side-effecting computations, we must be somewhat careful about
order. Optionally, we can expose incomplete or ambiguous pattern
matching as concrete effects.

The target language of pattern matching compilation, Core Frank,
replaces multi-handlers with a combination of call-by-value functions,
case statements, and unary effect handlers.

The syntax of Core Frank is given in Figure~\ref{fig:core-syntax}.
%
\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V          &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C             &::=& R \mid V \to C \\
\slab{returners}    &R             &::=& \effbox{\sigs}V
\\[1ex]
\slab{quantifiers}  &Z             &::=& X \mid \varepsilon \\
\slab{polytypes}    &P             &::=& \forall \many{Z}.Q \\
\slab{thunks}       &Q             &::=& \thunk{C}
\\[1ex]
\slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
\slab{effects}      &\sigs         &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}
                    &\Gamma        &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

Terms
\begin{syntax}
\slab{inferable values}&u       &::=& x \mid f \mid d                                \\
\slab{checkable values}&v       &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferable computations}&d &::=& \force{u} \mid d~v \mid c
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checkable computations} &e  &::= & v \mid \lambda x.e \\
   &&\mid& \key{case}~u~\key{of}~
             (k~\many{x_k} \mapsto e_k)_k \\
   &&\mid& \key{handle}~d~\key{with}~
             \bstack
             (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
             \medvert~ x        \mapsto e \\
             \estack \\
\end{syntax}
\caption{Core Frank Syntax}
\label{fig:core-syntax}
\end{figure}
%
The Core Frank typing rules are given in Figure~\ref{fig:core-typing}.
%
\begin{figure*}[float]
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{V \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \many{Z}.Q \in \Gamma \\
   \dom(\theta) = \set{\many{Z}} \\
   \varepsilon \in \dom(\theta) \implies \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(Q)}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{U} \\ U = V}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{C}{e}}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \has{\Gamma}{\sigs \oplus \sigs'}{V}{v}}
  {\can{\Gamma}{\sigs}{d~v}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs}
  {\cangs{c}{\many{V} \to \effbox{\sigs}U}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\does{\Gamma, \many{f : \forall \many{Z}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\doesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesg{\effbox{\sigs}V}{v}}

\inferrule
  {\does{\Gamma, x:V}{C}{e}}
  {\doesg{V \to C}{\lambda x.e}}

\inferrule
  {\makesgs{u}{D~\many{U}} \\
   \\ \effs{C}{\sigs} \\
   (\does{\Gamma, \many{x_k}:\many{V}}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
  {\doesg{C}{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}}

\inferrule
  {\sigs' \text{ closed} \\
   \effs{C}{\sigs} \\
   \can{\Gamma}{\sigs \oplus \sigs'}{d}{\effbox{\sigs \oplus \sigs'}{V}} \\
   (\does{\Gamma, \many{x_c}:\many{V}, g_c:\thunk{U \to \effbox{\sigs \oplus \sigs'}{V}}}
         {C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
   \does{\Gamma, x:V}{C}{e}}
  {\does{\Gamma}
         {C}{\key{handle}~ d ~\key{with}~
               (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
                x \mapsto e}}
\end{mathpar}

\caption{Core Frank Typing Rules}
\label{fig:core-typing}
\end{figure*}


%% The syntax of Core Frank is given in Figure~\ref{fig:core-syntax}.

%% \begin{figure}
%% Types
%% \begin{syntax}
%% \slab{values}       &U, V   &::=& D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
%% \slab{computations} &C      &::=& \rt{V} \mid V \to C
%% \\[1ex]
%% \slab{polytypes}    &P      &::=& \forall \varepsilon \many{X}.Q \\
%% \slab{thunks}       &Q      &::=& \effbox{\sigs}\thunk{C}
%% \\[1ex]
%% \slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
%% \slab{effects}      &\sigs  &::=&
%%   \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
%% \\[1ex]
%% \slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \mid f:P \\
%% \end{syntax}

%% Terms
%% \begin{syntax}
%% \slab{inferable values}       &u  &::= & x \mid f \mid d                           \\
%% \slab{checkable values}       &v  &::= & u \mid k~\many{v} \mid \thunk{e}
%% \\[1ex]
%% \slab{inferable computations} &d  &::= & \force{u} \mid d~v \mid c~\many{v}
%%                                    \mid  \key{let}~x=d~\key{in}~d' \\
%%                               &   &\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
%% \slab{checkable computations} &e  &::= & v \mid \lambda x.e \\
%%   &&\mid& \key{case}~u~\key{of}~
%%             (k~\many{x_k} \mapsto e_k)_k \\
%%   &&\mid& \key{handle} ~d~ \key{with}
%%             \bstack
%%             ~~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
%%             \medvert~ x        \mapsto e \\
%%             \estack \\
%% \end{syntax}
%% \caption{Core Frank Syntax}
%% \label{fig:core-syntax}
%% \end{figure}


%% A superficial change to the types is that rather than annotating value
%% returning computations with effects, we shift such labels to the thunk
%% containing the computation. The former design seems more convenient to
%% program with, which is why we adopt it in the source language. The
%% latter design leads to a slightly more uniform presentation of the
%% type rules (the checking judgement for computations now has the same
%% shape as the checking judgement for values, and we no longer need the
%% $\judgeword{does}$ judgement).
%
%% The typing rules of Core Frank are given in
%% Figure~\ref{fig:core-syntax}.

%%%%% Core Frank

%% \begin{figure*}[float]
%% $\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
%% \begin{mathpar}
%% \inferrule
%%   {x:V \in \Gamma}
%%   {\makesgs{x}{V}}

%% %% \inferrule
%% %%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%% %%    \theta(\varepsilon) = \sigs}
%% %%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

%% \inferrule
%%   {f:\forall \varepsilon \many{X}.V \in \Gamma \\
%%    \dom(\theta) = \set{\varepsilon, \many{X}} \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makesgs{f}{\theta(V)}}

%% \inferrule
%%   {\cangs{d}{\rt{V}}}
%%   {\makesgs{d}{V}}
%% \end{mathpar}

%% $\boxed{\has{\Gamma}{\sigs}{V}{v}}$

%% \begin{mathpar}
%% \inferrule
%%   {\makesgs{u}{V}}
%%   {\hasgs{V}{u}}

%% \inferrule
%%   {(\hasgs{V_i}{v_i})_i \\
%%    k~\many{V} \in D~\many{U}}
%%   {\hasgs{D~\many{U}}{k~\many{v}}}

%% \inferrule
%%   {\cdoes{\Gamma}{\sigs'}{C}{e}}
%%   {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
%% \end{mathpar}

%% $\boxed{\can{\Gamma}{\sigs}{d}{C}}$

%% \begin{mathpar}
%% \inferrule
%%   {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
%%   {\cangs{\force{u}}{C}}

%% \inferrule
%%   {\cangs{d}{V \to C} \\
%%    \has{\Gamma}{\sigs}{V}{v}}
%%   {\cangs{d~v}{C}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\cangs{d}{\effbox{\sigs}V} \\
%%    \can{\Gamma, x:V}{\sigs}{d'}{C}}
%%   {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

%% \inferrule
%%   {(\does{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{e_i}{Q_i})_i \\
%%    \can{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{d}{C}}
%%   {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.Q = e}~\key{in}~d}{C}}
%% \end{mathpar}

%% $\boxed{\cdoesgs{C}{e}}$

%% \begin{mathpar}
%% \inferrule
%%   {\hasgs{V}{v}}
%%   {\cdoesgs{\rt{V}}{v}}

%% \inferrule
%%   {\cdoes{\Gamma, x:V}{\sigs}{C}{e}}
%%   {\cdoesgs{V \to C}{\lambda x.e}}

%% \inferrule
%%   {\makesgs{u}{D~\many{U}} \\
%%    (\cdoes{\Gamma, \many{x_k}:\many{V}}{\sigs}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
%%   {\cdoesgs{C}{\key{case}~ u ~\key{of}~
%%                (k~\many{x_k} \mapsto e_k)_k}}

%% \inferrule
%%   {\sigs' \text{ closed} \\
%%    \can{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
%%    (\cdoes{\Gamma, \many{x_c}:\many{V}, g_c:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
%%          {\sigs}{C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
%%    \cdoes{\Gamma, x:V}{\sigs}{C}{e}}
%%   {\cdoes{\Gamma}{\sigs}
%%          {C}{\key{handle}~ d ~\key{with}~
%%                (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
%%                 x \mapsto e}}
%% \end{mathpar}

%% \caption{Core Frank Typing Rules}
%% \label{fig:core-typing}
%% \end{figure*}

Multi-handlers in Frank become curried functions over suspended
computations in Core Frank.
%
Shallow pattern matching on a single request becomes unary effect
handling. Shallow pattern matching on a datatype value becomes case
analysis. Nested pattern matching on multiple computations is realised
as a pattern matching tree constructed from handlers and case
statements. 

We may adapt standard algorithms for pattern matching compilation
apply~(e.g. \cite{Augustsson85} or \cite{Maranget08}). Rather than
comitting to a particular one, we outline how a pattern matching
compiler fits into our setting, what input it takes, and what kind of
output it must produce.

\begin{sloppypar}
Given a Frank expression $\thunk{e}$ such that $\doesg{R_1 \dots R_n
  \to R}{e}$
%
we compile it to an equivalent Core Frank expression $\thunk{\pc{e}}$.
%
First we expand all of the clauses in $e$ to yield an $n$ column
pattern matrix. For instance, suppose the arguments have types
$\effbox{\var{Send~Char}, \var{Abort}}\var{Unit}$ and
$\effbox{\var{Receive~Char}}$, and we have the following clauses:
\end{sloppypar}
\[
\ba{@{}l@{~}l@{~}l@{}}
  (\handle{\var{send}~x}{s}) & (\handle{\var{receive}}{r}) & \mapsto e_1 \\
  (\handle{\var{send}~x}{s}) & z & \mapsto e_2 \\
  (\handle{\var{abort}}{s})  & e_3 \\
  \var{unit} & e_4 \\
\ea
\]
%
then this becomes:
%
\[
\ba{@{}l@{\quad}l@{~\mapsto~}l@{}}
  (\handle{\var{send}~x}{s}) & (\handle{\var{receive}}{r}) & e_1 \\
  (\handle{\var{send}~x}{s}) & z & e_2 \\
  (\handle{\var{abort}}{s})  & z & \var{bind}~x~e' \\
  \var{unit}                 & z & \var{bind}~z~e_4 \\
\ea
\]
%
where $\var{bind}$ is defined in Section~\ref{sec:examples}.
%
Next we generate a vector of fresh variables, one for each argument.
\[
\ba{@{}l@{~}l@{}}
  x_0 & x_1
\ea
\]
The goal of pattern matching compilation is to generate a pattern
matching tree that matches the variable vector against all of the
patterns in the pattern matrix in the correct order.

In Frank, pattern matching trees $M$ are built up from leaves, case
analysis, and handlers.
%% \begin{equations}
%% M &::= & \many{e} \\
%%   &\mid& \key{case}~(x:D~\many{U})~\key{of}~(k~\many{x_k} \mapsto M_k)_{k \in D} \\
%%   &\mid& \key{handle}~(\force{x}:\effbox{\sigs}V)~\key{with}~
%%           (\handle{c~\many{x_c}}{g_c} \mapsto M_c)_{c \in \sigs} \medvert
%%           x        \mapsto M
%% \end{equations}%
\begin{equations}
M &::= & \many{e} \\
  &\mid& \key{case}~x~\key{of}~(k~\many{x_k} \mapsto M_k)_{k \in D} \\
  &\mid& \key{handle}~\force{x}~\key{with}~
          (\handle{c~\many{x_c}}{g_c} \mapsto M_c)_{c \in \sigs} \medvert
          x        \mapsto M
\end{equations}%
The leaves consist of a sequence of checkable computation
expressions. Each element corresponds to one way of matching all of
the patterns. If there exists a leaf with no elements, then the
pattern matching is incomplete; if there exists a leaf with multiple
elements, then the pattern matching is ambiguous.
%
Our default strategy (as indicated by the thunk introduction rule) is
to class incomplete pattern matching as a type error, and to keep only
the first element in the case of ambiguous pattern matching.
%
Our example generates the following pattern matching tree:
\[
M = \bstack
    \key{handle}~\force{x_0}~\key{with} \\
    \quad  \handle{\var{send}~x}{s} \mapsto \\
    \quad\quad \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad \handle{\var{receive}}{r} \mapsto e \\
    \quad\quad\quad z \mapsto e2 \\
    \quad  \handle{abort}{s} \mapsto \\
    \quad\quad \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad    \handle{receive}{r} \mapsto \var{bind}~(\force{r}~\force{receive})~e_3 \\
    \quad\quad\quad    z \mapsto \var{bind}~z~e_3 \\
    \quad  y \mapsto \\
    \quad\quad  \key{case}~y~\key{of} \\
    \quad\quad\quad  \var{unit} \mapsto \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad\quad    \handle{receive}{r} \mapsto \var{bind}~(\force{r}~\force{receive})~e_4 \\
    \quad\quad\quad\quad    z \mapsto \var{bind}~z~e_4 \\
\estack
\]
%
from which we obtain the corresponding Core Frank code by abstracting
over the fresh variables.
%
\[
\lambda x_0~x_1.M
\]
Some pattern matching operations reorder columns as an
optimisation. Column reordering is not in general a valid optimisation
in Frank. This is because commands in the ambient effects, but not in
the argument effects, are implicitly forwarded, and the order in which
they are forwarded is left-to-right. (The forwarding behaviour is made
precise in the Section~\ref{sec:semantics}.)

Of course, because Core Frank takes values as arguments whereas Frank
takes computations, each argument must be wrapped in a thunk
constructor.
%
The type translation is given simply by the homomorphic extension of the
following equation on function types:
\begin{equations}
\pc{\effbox{\sigs}V} \to \pc{C} &=& \thunk{\effbox{\pc{\sigs}}\pc{V}} \to \pc{C} \\
\end{equations}

A correct pattern matching translation $\pc{-}$ from Frank to Core
Frank should be type preserving.
\begin{itemize}
\item If $\makesgs{u}{V}$ then $\makes{\pc{\Gamma}}{\pc{\sigs}}{\pc{u}}{\pc{V}}$.
\item If $\hasgs{V}{v}$   then $\has{\pc{\Gamma}}{\pc{\sigs}}{\pc{V}}{\pc{v}}$.
\item If $\cangs{d}{C}$   then $\can{\pc{\Gamma}}{\pc{\sigs}}{\pc{d}}{\pc{C}}$.
%%\item If $\doesg{C}{e}$  then $\does{\pc{\Gamma}}{\pc{C}}{\pc{e}}$.
\end{itemize}

\subsection{Incomplete and Ambiguous Pattern Matching as Effects}

As an extension to Frank, we might allow incomplete and ambiguous
pattern matching. The former may be permitted if the ambient effects
contain the $\var{Abort}$ signature, in which case incomplete patterns
are translated into the $\var{abort}:\var{Zero}$ command, which can
then be handled however the programmer wishes. Similarly, we can define
a $\var{choice}:X(X, X)$ command, in order to allow ambiguous pattern
matches to be handled by the programmer.

%% \begin{equations}
%% \pc{D~\many{U}) &=& D~\pc{\many{U}} \\
%% \pc{\thunk{C}}  &=& \thunk{\pc{C}} \\
%% \pc{X} &=& X
%% \\[1ex]
%% \pc{\effbox{\sigs}V} &=& \effbox{\pc{\sigs}}\pc{V} \\
%% \pc{\effbox{\sigs}V} \to \pc{C} &=& \thunk{\effbox{\pc{\sigs}}\pc{V}} \to \pc{C} \\
%% \\[1ex]
%% \pc{\emptyset} &=& \emptyset \\
%% \pc{\sigs, S~\many{V}} &=& \pc{\sigs}, S~\pc{\many{V} \\
%% \pc{\varepsilon} &=& \varepsilon \\
%% \\[1ex]
%% \pc{\cdot} &=& \cdot \\
%% \pc{c:U(\many{V}), S~\many{X}} &=& 
%% \end{equations}


\section{Explicit Control Flow and Polymorphism}
\label{sec:feff}

In order to make control flow explicit, and to ease the definition of
an operational semantics, we translate Core Frank into a
call-by-push-value calculus \feff based on Kammar et al's
\lameff~\cite{KammarLO13}.

At the same time, we make polymorphism explicit. The syntax of \feff
is given in Figure~\ref{fig:feff-syntax}. Broadly, \feff types are
similar to Frank types, with an explicit division between value type
and computation types. A superficial difference is that rather than
annotating value returning computations with effects, we shift such
labels to the thunk containing the computation. The former design
seems more convenient to program with, which is why we adopt it in the
source language. The latter design leads to a more uniform
presentation of the typing rules, and matches the design of
\lameff. Another minor difference is that in \feff commands must
always be fully applied, which leads to a slightly cleaner operational
semantics.
%
\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid \forall \many{Z}.\effbox{\sigs}\thunk{C} \mid X \\ % \mid \forall X.V \\
\slab{computations} &C      &::=& \rt{V} \mid V \to C  % \mid \forall X.C \\
\\[1ex]
\slab{quantifiers}  &Z      &::=& X \mid \varepsilon \\
\slab{arguments}    &T      &::=& V \mid \sigs
\\[1ex]
\slab{polytypes}    &P      &::=& \forall \many{Z}.Q \\
\slab{monothunks}   &Q      &::=& \effbox{\sigs}\thunk{C}
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \\
\end{syntax}

%% Effect extension
%% \begin{equations}
%% \sigs \oplus \emptyset               &=& \emptyset \\
%% \sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
%% \end{equations}

Terms
\begin{syntax}
\slab{values}       &u, v &::=& x \mid k~\many{v} \mid \Lambda \many{Z}.\thunk{d} \\
%%             \mid \Lambda Z.v \mid u~T \\
\slab{computations} &d, e &::=& \key{case}~u~\key{of}~
                                   (k~\many{x_k} \mapsto e_k)_k
                                \mid \force{(u~\many{T})} \\
                    &     &\mid& \lambda x.e \mid d~v 
                           \mid \key{ret}~v \mid \key{let}~x=e~\key{in}~e'
%%                           \mid c \\
                           \mid c~\many{v} \\
%%   \mid \Lambda Z.e \mid d~T \\
                         &&\mid& \key{handle} ~d~ \key{with}~
                                   (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
                                   x        \mapsto e \\
                         &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~e' \\
\end{syntax}
\caption{\feff Syntax}
\label{fig:feff-syntax}
\end{figure}



\begin{figure*}
$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\Lambda \many{Z}.\thunk{e}}{\forall \many{Z}.\effbox{\sigs}\thunk{C}}}
%% \inferrule
%%   {\valg{v}{V} \\
%%    Z \notin \FV(\Gamma)}
%%   {\valg{\Lambda Z.v}{\forall Z.V}}
%% \inferrule
%%   {\valg{u}{\forall Z.V}}
%%   {\valg{u~T}{V[T/Z]}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\forall \many{Z}.\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{(u~\many{T})}}{C[\many{T}/\many{Z}]}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {\compgs{d}{\rt{V}} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\key{let}~x=d~\key{in}~e}{C}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs}
%%   {\compgs{c}{\many{V} \to U}}


\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\compgs{e}{C} \\
%%    Z \notin (\FV(\Gamma) \cup \FV(\sigs))}
%%   {\compgs{\Lambda Z.e}{\forall Z.C}}

%% \inferrule
%%   {\compgs{d}{\forall Z.C}}
%%   {\compgs{d~T}{V[T/Z]}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}

\inferrule
  {(\comp{\Gamma, \many{f : \forall\many{Z}.Q}}{\sigs}{e_i}{Q_i})_i \\
   \comp{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\compgs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

\caption{\feff Typing rules}
\label{fig:feff-typing}
\end{figure*}
%
The typing rules for \feff are given in
Figure~\ref{fig:feff-typing}. Typing in \feff is unidirectional.

Call-by-push-value calculi such as \lameff and \feff make a strict
separation between values and computations, not dissimilar from CPS or
A-normal form representations, in which all reduction takes place at
the level of computations. In such a setting it would seem most
natural to add type abstractions to computations rather than
values. However, this does not give us what we need in the presence of
effects, as we need to be able to quantify over effects. Our solution
is to build the universal quantifier into the thunk type (the
introduction rule for thunks is the place where ambient effects are
reified in a type) and build type application into forcing.

The type translation from Core Frank to \feff is given by the
homomorphic extension of the following equations:
\begin{equations}
\sem{\thunk{C}} &=& \effbox{\sem{\sigs}}\thunk{\sem{C}}, \quad \text{where }\effs{C}{\sigs} \\
\sem{\effbox{\sigs}V \to C} &=& \effbox{\sem{\sigs}}\sem{V} \to \sem{C} \\
\sem{\effbox{\sigs}V} &=& \rt{\sem{V}}\\
\end{equations}%
%
  %% drop ([Sig]{C}) = {drop(C) drop(Sig)}
  %%
  %% drop ( <V> ) Sig          = [ drop (Sig) ] drop(V)
  %% drop ( [Sig']V -> C ) Sig = [ drop (Sig') ] drop(V) -> drop(C) drop(Sig)
%
In order to simplify the definition of the term translation, we
annotate instances of polymorphic variables $f$ with the type
arguments they are instantiated with as a pre-processing step.
%
The term translation is a call by value embedding of Core Frank into
\feff:
%
\begin{equations}
\sem{x} &=& \key{ret}~x \\
\sem{f^{\many{T}}} &=& f~\sem{\many{T}} \\
\\
\sem{k~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~\key{ret}~(k~\many{x}) \\
\sem{\thunk{e}} &=& \key{ret}~\thunk{\sem{e}} \\
\\
%% \sem{c} &=& c \\
\sem{c : V_1 \to \dots \to V_n \to R} &=& \lambda x_1 \dots x_n.c~x_1~\dots~x_n \\
%% \sem{c~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~c~\many{x} \\
\sem{d~v} &=& \key{let}~x=\sem{v} ~\key{in}~d~x \\
\sem{\force{u}} &=& \key{let}~x=\sem{u} ~\key{in}~\force{x} \\
\\
\sem{\lambda x.e} &=& \lambda x.\sem{e} \\
\multicolumn{3}{@{}l}{\sem{\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{let}~x=\sem{u} ~\key{in}~
    \key{case}~x~\key{of}~(k~\many{x_k} \mapsto \sem{e_k})_k} \\
\multicolumn{3}{@{}l}{\sem{\key{handle}~d~\key{with}~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert x \mapsto e} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{handle}~\sem{d}~\key{with}~ 
            (\handle{c~\many{x_c}}{g_c} \mapsto \sem{e_c})_c
            \medvert x \mapsto \sem{e}} \\
\end{equations}%
%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {f:\forall \varepsilon \many{X}.V \in \Gamma \\
%%      \dom(\theta) = \set{\varepsilon, \many{X}} \\
%%      \theta(\varepsilon) = \sigs}
%%     {\makesgs{f}{\theta(V)}}
%% \semr \qquad \\[3ex]
%% \hfill = \force{(f~\sigs~\many{\theta(X)})} \\
%% \el
%% \]
%


\begin{proposition}
The translation $\sem{-}$ from Core Frank to \feff is type preserving.
\begin{itemize}
\item If $\makesgs{u}{V}$ then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{u}}{\rt{\sem{V}}}$.
\item If $\hasgs{V}{v}$   then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{v}}{\rt{\sem{V}}}$.
\item If $\cangs{d}{C}$   then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{d}}{\sem{C}}$.
\item If $\doesg{C}{e}$ and $\effs{C}{\sigs}$ then
  $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{e}}{\sem{C}}$.
\end{itemize}
\end{proposition}

Kammar et al~\cite{KammarLO13} classify a number of different
varieties of handler.
%
The handlers in \feff (and indeed Frank) are \emph{shallow} in that,
unlike Plotkin and Pretnar's original deep handlers, the handler is
not automatically rewrapped around the continuation when handling a
command. Roughly, deep handlers perform a fold over computations,
whereas shallow handles perform a case split. Deep handlers are
denotationally better behaved than shallow handlers, but shallow
handlers sometimes appear more convenient to program with.
%
The handlers in \feff (and indeed Frank) are polymorphic forwarding
handlers. The form of polymorphism amounts to a kind of row
polymorphism with shadowing, unlike the more conventional kind of row
polymorphism suggested by Kammar et al.

%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:V}{x}{\theta(V)}}
%% \semr
%% = \\
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:\forall \many{Z}.V}{x~\theta(\many{Z})}{\theta{V}}} \\
%% \el
%% \]


\section{Small-step semantics}
\label{sec:semantics}

We give a small step operation semantics for \feff inspired by Kammar
et al's semantics for \lameff~\cite{KammarLO13}.
%
All of the rules except the ones for handlers are pretty standard
$\beta$-reductions.
%
The rules for forcing are slightly unusual due to the hard-wiring of
polymorphism into thunks.

Returns $\key{ret}~v$ are handled by substituting the value into the
handler's return clause. Commands are handled by capturing the
continuation up to the current handler and dispatching to the
appropriate clause for the command. If a clause is defined in the
handler, then that clause is selected. If not, then the command is
forwarded to be handled by an outer handler, but its continuation is
handled by the current handler.

Delimited computation contexts $D$ are used to characterise the
continuation up to the current handler. Computation contexts $E$
amount to evaluation contexts for a call-by-push-value setting.

\begin{figure*}

\begin{equations}
%% (\textrm{Value contexts})\, D
%%   &::=& [~] \mid \key{case}~D~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i \mid \force{D} \mid D~T \\
(\textrm{Delimited computation contexts})\, D
  &::=& [~] \mid D~v \mid \key{let}~x=D~\key{in}~e \\
(\textrm{Computation contexts})\, E
  &::=& [~] \mid E~v \mid \key{let}~x=E~\key{in}~e
            \mid \key{handle}~E~\key{with}~H \\
               %% (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
               %%   x \mapsto e \\
\end{equations}%

\begin{equations}
%% (\Lambda Z.v) T &\reducesto& v[T/Z]
%% \\[1ex]
\key{case}~k_j~\many{v}~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i
  &\reducesto& e_j[\many{v}/\many{x_j}] \\
\force{((\Lambda \many{Z}.\thunk{e})~\many{T})} &\reducesto& e[\many{T}/\many{Z}]
\\[1ex]
(\lambda x.e)~v &\reducesto& e[v/x] \\
%% (\key{rec}~f~x.e)~v &\reducesto& e[\thunk{\key{rec}~f~x.e}/f, v/x] \\
\key{let}~x=\key{ret}~v~\key{in}~e &\reducesto& e[v/x] \\
\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d
  &\reducesto&
    d[\many{\Lambda{Z}.\thunk{e}}
       [\many{\Lambda{Z}.
                \thunk{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~\force{(f~\many{Z})}}}
       / \many{f}]
     /\many{f}]
\\[1ex]
\key{handle}~(\key{ret}~v)~\key{with}~H
  &\reducesto& H(\key{ret}, v) \\
\key{handle}~D[c~\many{v}]~\key{with}~H
  &\reducesto& H(c, \many{v}, \thunk{\lambda z.D[\key{ret}~z]}) \\
%% \key{handle}~(\key{ret}~v)~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%     \key{let}~x=\key{ret}~v~\key{in}~e \\
%% \key{handle}~E[c_j~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      e_j[\many{v}/\many{x_j}, \thunk{\lambda z.E[\key{ret}~z]} / g] \\
%% \key{handle}~E[c~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      \key{let}~z=c~\many{v}~\key{in}~
%%        \key{handle}~E[\key{ret}~z]~\key{with}~
%%           (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%           x \mapsto e, \quad c \neq c_i \text{ for any }i \\
\end{equations}%
where the action of $H = (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert x
\mapsto e$ is given by:
\begin{equations}%
H(\key{ret}, v) &=& e[v/x] \\
H(\key{c_j}, \many{v}, u) &=& e_j[\many{v}/\many{x}, u/g] \\
H(\key{c}, \many{v}, u)
  &=& \key{let}~z=c~\many{v}~\key{in}~
        \key{handle}~\force{u}~z~\key{with}~H,
           \quad c \neq c_i\text{ for any }i
\end{equations}%

\begin{mathpar}
%% \inferrule
%%   {u \reducesto v}
%%   {D[u] \reducesto D[v]}

\inferrule
  {d \reducesto e}
  {E[d] \reducesto E[e]}
\end{mathpar}

\caption{Small-step operational semantics for \feff}
\label{fig:semantics}
\end{figure*}

\begin{proposition}[Type Soundness]
~
\begin{itemize}
\item If $\compgs{d}{C}$ and $d \reducesto e$ then $\compgs{e}{C}$.
\item If $\comp{\cdot}{\emptyset}{d}{\rt{V}}$ then either there exists $v$
  such that $d = \key{ret}~v$ or there exists $e$ such that $d \reducesto
  e$.
\end{itemize}
\end{proposition}

\section{Related Work}
\label{sec:related}

We have discussed much of the related work throughout the paper. Here
we briefly mention some other related work.

A natural implementation for handlers is to use \emph{free
  monads}~\cite{KammarLO13}. Swierstra~\cite{Swierstra08} illustrates
how to write effectful programs with free monads in Haskell, taking
advantage of type-classes to provide a certain amount of modularity.

Inspired by Bauer and Pretnar's Eff, Visscher has implemented the
\texttt{effects} library~\cite{Visscher12}. The key idea is to layer
continuation monads in the style of Filinski~\cite{Filinski99}, using
Haskell type classes to automatically infer lifting between layers.

Filinski's work on monadic reflection and layered monads is closely
related to effect handlers~\cite{Filinski10}. Monadic reflection
supports a similar style of composing effects. The key difference is
that monadic reflection interprets monadic computations in terms of
other monadic computations, rather than abstracting over and
interpreting operations

Languages other than Frank that attempt to elide some effect variables
from source code include Links~\cite{LindleyC12} and Daan Leijen's
Koka~\cite{Leijen13}. Neither eliminates effect variables altogether.

Swamy et al~\cite{SwamyGLH11} add support for monads in ML, supporting
direct-style effectful programming in a strict language. Unlike Frank,
their system is based on monad transformers rather than effect
handlers.


\section{Future Work}
\label{sec:future}

Our first priority is to implement a prototype for the current Frank
design. Having done that, there is much scope for exploring different
implementations of handlers, both for performance and for exploring
new abstractions.
%
We would like to combine effect handlers with richer type systems,
following the work of McBride~\cite{McBride11} and
Brady~\cite{Brady13}.
%
Handlers provide some of the same functionality as modules and type
classes. We would like to formally relate all three abstractions.
%
We are exploring algebraic effects and effect handlers for
idiom~\cite{McbrideP08} and arrow~\cite{Hughes04} computations.

%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules


%% \section{Conclusion and Future Work}
%% \label{sec:conclusion}

%% TODO: write this section?


%% \begin{abstract}
%% This is the text of the abstract.
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keys
%% keyword1, keyword2

%% \section{Introduction}

%% The text of the paper begins here.

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{frankly}

% The bibliography should be embedded for final submission.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\end{document}

%%  LocalWords:  Lindley Conor Strathclyde Plotkin Pretnar's Multi et
%%  LocalWords:  effectful modularity polymorphism Kammar al Pretnar
%%  LocalWords:  Hindley Milner Oury SML Haskell monadic Kiselyov DSL
%%  LocalWords:  Idris Brady's equational multi unary al's datatypes
%%  LocalWords:  datatype Vn typecheck Ri catter polytypes inferable
%%  LocalWords:  checkable letrec monomorphic reifying desugars ret
%%  LocalWords:  homomorphic monothunks reified pre rewrapped monads
%%  LocalWords:  denotationally Swierstra Visscher Filinski Daan Koka
%%  LocalWords:  Filinski's Leijen's Swamy monad
