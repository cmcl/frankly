\documentclass[preprint]{sigplanconf}

% US Letter page size
%\pdfpagewidth=8.5in
%\pdfpageheight=11in


% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{xspace}

\newcommand{\lameff}{$\lambda_\mathrm{eff}$\xspace}
\newcommand{\feff}{$F_\textrm{eff}$\xspace}
\newcommand{\impeff}{Implicit \lameff}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\many}{\overline}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}

\newcommand{\seml}{\left\llbracket}
\newcommand{\semr}{\right\rrbracket}

\newcommand{\pc}[1]{\llparenthesis{#1}\rrparenthesis}

\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}

\newcommand{\reducesto}{\longrightarrow}

\newcommand\ba{\begin{array}}
\newcommand\ea{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newcommand{\bstack}{\begin{array}[t]{@{}l@{}}}
\newcommand{\estack}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newenvironment{syntax}{\[\ba{@{}l@{~}r@{~}c@{~}l@{}}}{\ea\]}


\newcommand{\judgeword}[1]{~\mathbf{#1}~}

%\renewcommand{\sig}{\Sigma}
%\renewcommand{\sigs}{\Sigma s}
\newcommand{\sigentails}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\text{-\!-}}\,}

\newcommand{\sigmodels}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\mathord{=}}\,}


% \newcommand{\sigentails}[1]{\vdash_{#1}}

\newcommand{\val}[3]  {#1 \vdash {#2} : {#3}}
\newcommand{\comp}[4]  {#1 \sigentails{#2} {#3} : {#4}}

\newcommand{\rt}[1]{\langle{#1}\rangle}   % returner type

\newcommand{\valg}{\val{\Gamma}}
\newcommand{\compgs}{\comp{\Gamma}{\sigs}}

%% \newcommand{\is}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
%% \newcommand{\isgs}{\is{\Gamma}{\sigs}}

\newcommand{\makes}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\has}[4] {#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\can}[4]{#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\does}[4]{#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\idoes}[3]{#1 \vdash {#2} \judgeword{has} {#3}}

\newcommand{\effs}[2]{{#1} \judgeword{does} {#2}}

\newcommand{\pat}[3]{{#1} \judgeword{matches} {#2} \dashv #3}
\newcommand{\patg}[2]{\pat{#1}{#2}{\Gamma}}

\newcommand{\makesgs}{\makes{\Gamma}{\sigs}}
\newcommand{\hasgs}{\has{\Gamma}{\sigs}}
\newcommand{\cangs}{\can{\Gamma}{\sigs}}
\newcommand{\doesgs}{\does{\Gamma}{\sigs}}
\newcommand{\idoesg}{\idoes{\Gamma}}


% Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\sig}{S}
\newcommand{\sigs}{\Sigma}

%% \newcommand{\sig}{\Sigma}
%% \newcommand{\sigs}{E}


%% \newcommand{\X}{X}  % a type variable

%% \newcommand{\E}{E}  % the effect variable

%% \newcommand{\U}{U}
%% \newcommand{\V}{V}
%% \newcommand{\Us}{\many{\U}}
%% \newcommand{\Vs}{\many{\V}}

%% \newcommand{\C}{C}

%% \newcommand{\tm}{t}
%% \newcommand{\tu}{u}
%% \newcommand{\tms}{\many{\tm}}
%% \newcommand{\tus}{\many{\tu}}

%% \newcommand{\p}{p}
%% \newcommand{\ps}{\many{\p}}

%% \newcommand{\h}{h}

%% \newcommand{\op}{\mathit{op}}

\newcommand{\effbox}[1]{[#1]}
%% \newcommand{\ret}[2]{\effbox{#1}{#2}}
%% \newcommand{\template}[3]{{#1} \mathbin{\effbox{#2}} {#3}}

\newcommand{\key}[1]{\mathsf{#1}}

\newcommand{\handleSymbol}{\mathbin{?}}
%% \newcommand{\yieldSymbol}{\mathbin{\prec}}
%% \newcommand{\continueSymbol}{\mathbin{\triangleleft}}
%% \newcommand{\handleType}[3]{\effbox{{#1} \yieldSymbol \ret{#2}{#3}}}
%% \newcommand{\handleTypePoly}[2]{\effbox{{#1} \yieldSymbol #2}}
%% \newcommand{\handleRet}[1]{\effbox{#1}}
%% \newcommand{\handleOp}[2]{\effbox{{#1} \continueSymbol {#2}}}
\newcommand{\handle}[2]{{#1} \handleSymbol {#2}}

%% \newcommand{\handleGen}[2]{\key{handle}~{#1}~\key{with}~{#2}}

\newcommand{\thunk}[1]{\{{#1}\}}
%\newcommand{\athunk}[2]{\thunk{#1}_{#2}}
%% \newcommand{\athunk}[2]{[#2]\thunk{#1}}

\newcommand{\force}[1]{{#1}!}
%% \newcommand{\app}{\mathbin{\text{@}}}

%% \newcommand{\con}{K}
%% \newcommand{\D}{D}

%% \newcommand{\args}{\mathit{args}}

%% \newcommand{\rplus}{\mathbin{\mathord{+}\!\!\!\!\mathord{\shortrightarrow}}}
%% \newcommand{\lplus}{\mathbin{\mathord{+}\!\!\!\!\!\mathord{\shortleftarrow}}}


%% \newcommand{\VV}{\mathbb{V}}
%% \newcommand{\VVs}{\many{\VV}}
%% \newcommand{\CC}{\mathbb{C}}

%% \newcommand{\inst}[2]{\mathit{inst}({#1}, {#2})}
%% \newcommand{\instt}[1]{\inst{\theta}{#1}}

%% \newcommand{\oldinst}[3]{\mathit{inst}({#1},{#2},{#3})}
%% \newcommand{\oldinstts}[1]{\oldinst{\theta}{\sigs}{#1}}

%% \newcommand{\appsig}[2]{{#1}\mathord{\cdot}{#2}}


\newcommand\slab[1]{(\textrm{#1})}


\begin{document}

%% \conferenceinfo{WXYZ '05}{date, City.} 
%% \copyrightyear{2005} 
%% \copyrightdata{[to be supplied]} 

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Do Be Do Be Do}
%% \subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}
           {The University of Edinburgh}
           {}
\authorinfo{Conor McBride}
           {University of Strathclyde}
           {}
%%         {Email1}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle

%% Structure:

%%   Introduction
%%   Examples
%%     parsing
%%     pipes
%%     ...
%%   Frank syntax and type system (source language)
%%     semantics by elaboration into successively simpler languages
%%   pattern matching compilation
%%     option to expose incomplete/ambiguous pattern matching as
%%     concrete effects
%%   CBPV
%%   Explicit polymorphism
%%   Small-step semantics (see handlers in action)
%%
%%   Related work
%%
%%     Plotkin+Power, Plotkin+Pretnar, Hancock, Eff, Brady, Kiselyov
%%     et al, Felleisen, Kammar et al, Filinski, Koka, Ahmen+Plotkin,
%%     Staton, Kleisli arrows of outrageous fortune, data types a la carte
%%
%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules

\section{Introduction}

This paper explores the design of Frank, a strict functional
programming language designed from the ground up around a novel
variant of Plotkin and Pretnar's \emph{effect
  handler}~\cite{PlotkinP09, PlotkinP13} abstraction.

In Frank, effect handlers strictly generalise functions. In the
general case an effect handler acts as an interpreter for a finite set
of commands whose signatures are statically tracked by the type
system. A function is the special case of an effect handler whose
command set is empty.

The contributions of this paper are:
\begin{itemize}
\item Frank, a functional programming language featuring a
  bidirectional effect type system, effect polymorphism, and effect
  handlers.
\item A novel approach to effect polymorphism which avoids all mention
  of effect variables, crucially relying on the observation that one
  must always instantiate the effects of a function being applied with
  the current \emph{ambient} effects.
\item The combination of pattern matching and effect handlers in such
  a way that incomplete or ambiguous pattern matching can be realised
  as concrete effects that can be handled however the programmer
  chooses using further effect handlers.
\item Multi-handlers as both an abstraction for handling multiple
  computations over different effect sets simultaneously and a
  characterisation of effect-handlers as generalised functions.
\item A prescription for perform pattern matching compilation for
  Frank into a core language Core Frank.
\item A translation from Core Frank into \feff a polymorphic variant
  of the \lameff calculus of Kammar et al~\cite{KammarLO13}, which in
  turn extends Levy's call-by-push-value calculus~\cite{Levy2004}.
\item A straightforward small-step operational semantics for \feff,
  yielding, in combination with the translation to \feff, a type
  soundness result for Frank.
\end{itemize}

A number of other languages and libraries are built around effect
handlers and algebraic effects.

Bauer and Pretnar's Eff~\cite{BauerP12}. A significant difference
between Frank and the original version of Eff~\cite{BauerP12} is that
the latter provides no support for effect typing. Recently Bauer and
Pretnar have designed an effect type system for
Eff~\cite{BauerP13}. Their implementation~\cite{Pretnar13} supports
Hindley-Milner type inference, and the type system incorporates effect
sub-typing. In contrast, Frank uses bidirectional type inference, and
avoids sub-typing altogether.

Handlers in action~\cite{KammarLO13}. In previous work with Kammar and
Oury~\cite{KammarLO13}, the first author designed and experimented
with a number of effect handler libraries for languages ranging from
Racket, to SML, to Haskell. Apart from the Haskell library, our other
libraries have no effect typing support. The Haskell library takes
advantage of type classes to simulate an effect type system not
entirely dissimilar to that of Frank. As Haskell is lazy, the Haskell
library cannot be used to write direct-style effectful programs - one
must instead adopt a monadic style. Furthermore, although there are a
number of ways of almost simulating effect type systems in Haskell,
none is without its flaws. Kiselyov et al~\cite{KiselyovSS13} have
designed a similar Haskell library for effect handlers, making
slightly different design choices.

Brady~\cite{Brady13} has designed a library and DSL for programming
with effects in his dependently typed Idris language. Like the Haskell
libraries, Brady's library currently requires the programmer to write
effectful code in a monadic style.

The second author has been plotting Frank since
2007~\cite{McBride07}. He has implemented a prototype of a previous
version of Frank~\cite{McBride12}. The design described in the current
paper has much in common with that implementation, but there are some
syntactic and semantic differences. The most important change in the
current design is the introduction of multi-handlers as a
generalisation of both functions and handlers.

The rest of the paper is structured as follows.
%
Section~\ref{sec:examples} introduces Frank by
example. Section~\ref{sec:frank} presents a type system for
Frank. Section~\ref{sec:core} describes how to elaborate
multi-handlers and pattern matching into Core Frank, a language of
plain call-by-value functions, explicit case analysis and unary
handler constructs. Section~\ref{sec:feff} gives a call-by-value
embedding of Core Frank into \feff, a variant of Kammar et al's
\lameff calculus with shallow handlers, explict polymorphism and
general recursion. Section~\ref{sec:semantics} gives a semantics for
\feff, which when composed with pattern matching and the call-by-value
embedding, yields a semantics for Frank. Section~\ref{sec:related}
outlines related work and Section~\ref{sec:conclusion} concludes.

\section{Introducing Frank}
\label{sec:examples}

Frank is a functional programming language with effects and handlers
in the style of Eff controlled by a type system inspired by Levy's
call-by-push-value~\cite{Levy2004}.
%
Doing and Being are clearly separated, and managed by distinguished
notions of computation and value types.

Concrete values live in inductive datatypes.
%
\begin{verbatim}
data List X
   = nil
   | cons X (List X)

data Zero =

data Unit = unit
\end{verbatim}

We can write perfectly ordinary functional programs, with (compulsory)
type signatures.
%
\begin{verbatim}
append : List X -> List X -> List X
append nil       ys = ys
append (x :: xs) ys = cons x (append xs ys)
\end{verbatim}

Higher-order functions are passed suspended computations. Braces are
"suspenders".
%
\begin{verbatim}
map {X -> Y} -> List X -> List Y
map f nil         = nil
map f (cons x xs) = cons (f x) (map f xs)
\end{verbatim}

A value type \verb!V! is a datatype \verb!D V1 ... Vn!, a suspended
computation type \verb!{C}!, or a type variable \verb!X!.
%
A computation type can be a function type \verb!V -> C! or an
effect-annotated value type \verb![S1 ... Sn]V!, where an empty
bracket may be omitted.

Effects are collections of signatures, which describe a choice of
commands. Here are some simple signatures.
%
\begin{verbatim}
sig Send X
  = send : Unit(X)

sig Receive X
  = receive : X

sig Abort
  = aborting : Zero
\end{verbatim}
%
The \verb!send! command takes an argument of type \verb!X! and returns
a value of type \verb!Unit!. The \verb!receive! command returns a
value of type \verb!X!. The abort command returns an element of the
empty type, \verb!Zero!.

Frank is a call-by-value language, but it naturally distinguishes
\verb![]V!, the type of suspended pure computations which deliver a
\verb!V!, from \verb!V! itself. We can thus define a kind of
"semicolon" just as the function which ignores its first argument.
%
\begin{verbatim}
semi : X Y -> Y
semi x y = y
\end{verbatim}

Frank has effect polymorphism, enough to allow higher-order functions
to pass effect permissions to their parameters. The following uses map
to send a list of things, one at a time.
%
\begin{verbatim}
sends : List X -> [Send X]Unit
sends xs = semi (map send xs) unit
\end{verbatim}
%
The reason this type checks at all is because \verb!map! is implicitly
polymorphic in its effects.

The following does not typecheck, because the \verb!Send! effect is
not permitted in the return type of \verb!bad!.

\begin{verbatim}
bad List X -> Unit
bad xs = semi (map send xs) unit
\end{verbatim}

Writing control operators is not too tricky.
\begin{verbatim}
bind : X -> {X -> Y} -> Y
bind x f = f x
\end{verbatim}

We can use \verb!bind! to define a polymorphic \verb!abort! function.
\begin{verbatim}
abort : [Abort]X
abort = bind aborting! {}
\end{verbatim}
The term \verb!{}! denotes a suspended computation containing an empty
collection of pattern matching clauses covering the \verb!Zero! return
type of \verb!aborting!.

Here is a computation which receives and concatenates lists until one
is empty.
%
\begin{verbatim}
catter : [Receive (List X)]List X
catter = bind receive!
           { nil -> nil
           | xs  -> append xs catter!
           }
\end{verbatim}
%
The command \verb!receive! is a suspended computation of type
\verb!{[Receive (List X)]List X}! that delivers a list when
forced. The notation \verb|receive!| forces a thunk.

If \verb!f! is a suspended computation of function type, then
\verb!f x! is syntactic sugar for \verb|f! x|. Thus we need only
explicitly force computations that take no arguments.

Effects are handled by special functions called \emph{effect
  handlers}. Effect handlers in Frank can take multiple computations
as arguments, hence they are \emph{multi-handlers}. In fact standard
functions like the ones we have seen so far are just special cases of
multi-handlers in which the all the arguments are pure.

A multi-handler has type \verb!R1 -> ... -> Rm -> R! where each
\verb!Ri! and \verb!R! is an effect-annotated value type. For
instance, we can write a \verb!pipe! multi-handler which handles
\verb!send! commands from one computation by matching them against
corresponding \verb!receive! commands from another.
%
\begin{verbatim}
pipe : [Send X]Unit -> [Receive X]Y -> [Abort]Y
pipe _            y             = y
pipe unit         _             = abort!
pipe (send x ? s) (receive ? r) =
  pipe (s unit) (r x)
\end{verbatim}
%
The type signature conveys several different things. The \verb!pipe!
  handler must handle all \verb!Send X! commands in its first argument
  and all \verb!Receive X! commands in its second argument. The first
  argument returns values of type \verb!Unit! and the second argument
  returns values of type \verb!Y!. The handler itself is allowed to
  perform \verb!Abort!  commands and returns a final value of type
  \verb!Y!.

Here are some things to send.
\begin{verbatim}
hello : List Char
hello =
  cons 'h' (cons 'e' (cons 'l'
    (cons 'l' (cons 'o' nil))))

space : List Char
space = cons ' ' nil

world : List Char
world =
  cons 'w' (cons 'o' (cons 'r'
    (cons 'l' (cons 'd' nil))))
\end{verbatim}
%
Here is a computation which sends them.
%
\begin{verbatim}
sender [Send (List Char)]Unit
sender =
  sends (cons (hello
           (cons space (cons world nil))))
\end{verbatim}

Here is a \verb!main! function, which plugs \verb!sender! and
\verb!catter!  together and sends their output to the console.
%
\begin{verbatim}
main : [Abort, Console](List Unit)
main = map ouch (pipe sender catter)
\end{verbatim}
where the \verb!Console! operations are handled specially at the
top-level according to the following signature.
\begin{verbatim}
sig Console
  = inch : Char(Unit)
  | ouch : Unit(Char)
\end{verbatim}

The type system does two separate things:
\begin{itemize}
\item It ensures that value types coincide.
\item It ensures that effects required are included in effects
  enabled.
\end{itemize}

The fun of Frank is that one can say what it is to \emph{be} a
computation without saying what it is to \emph{do} it. Doing and being
are separately negotiable, and readily interleaved in different
ways. Or as Frank Sinatra put it,
\begin{quote}
do be do be do
\end{quote}

\subsection{Pipes}

\subsection{Modular rollback}

\subsection{Effect polymorphism with an invisible effect variable}

Let us consider the canonical example of a polymorphic higher-order
function \verb|map|.
\begin{verbatim}
data List X = nil | cons X (List X)

map : (X -> Y) -> List X -> List Y
map f nil         = nil
map f (cons x xs) = cons (f x) (map f xs)
\end{verbatim}
The type we have given to map is the standard one a functional
programmer might expect to write in a language without support for
effect typing.
%
Though it looks polymorphic



%
We automatically translate it into a valid Frank type by applying a
series of desugaring rules.

The valid Frank type we are after is:
\begin{verbatim}
forall e X Y.{[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)}
\end{verbatim}

First, for readability we allow the signature for recursively defined
functions to be defined on a separate line, as in Haskell.
%
Second, we allow the quantifiers to be omitted, just like in Haskell.
\begin{verbatim}
{[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)}
\end{verbatim}
Third, we allow the outer braces to be omitted, as the type must always be a thunk.
\begin{verbatim}
[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)
\end{verbatim}

%% S~\many{V} == 0, S~\many{V}
%% S~\many{V} == e, S~\many{V}

Let us distinguish between returners $\effbox{\sigs}V$ in argument
position, whose effects $\sigs$ must be closed, and those in tail
position, whose effects need not be closed. We call the former
\emph{ports}, and the latter \emph{pegs}.

Now we take advantage of some more general desugaring rules.
\begin{equations}
                      V &\equiv& \effbox{\varepsilon}V \\
                V \to C &\equiv& \effbox{\emptyset}V \to C \\
\effbox{\sigs}(R \to C) &\equiv& \effbox{\sigs}\thunk{R \to C} \\
\end{equations}
where the first rule is restricted to pegs (it would be nonsensical
for ports anyway, as their effects must always be closed).

The first rule is the critical one. It allows us to avoid writing down
the effect variable. The second rule makes sense as ports being closed
means that writing down $\emptyset$ is redundant. The third rule is
superficial.

Applying each rule in turn we obtain:
\begin{verbatim}
[0]{[0]X -> [e]Y} -> [0](List X) -> [e](List Y)
[0]([0]X -> [e]Y) -> [0](List X) -> [e](List Y)
[0]([0]X ->    Y) -> [0](List X) ->     List Y 
   (   X ->    Y) ->     List X  ->     List Y 
\end{verbatim}

In order to account for non-empty effect sets, we also apply the
following rules:
\begin{equations}
S~\many{V} &\equiv& \varepsilon, S~\many{V} \\
S~\many{V} &\equiv& \emptyset, S~\many{V} \\
\end{equations}
where the first only applies to peg effect sets, and the second only
applies to port effect sets.

\newcommand{\var}{\mathit}

For instance:
\[
\bstack
\thunk{\effbox{\var{Abort}}\var{Int} \to \effbox{\var{State}~\var{Int}}\var{Bool}} \to \var{Int}
\equiv \\
  \qquad \thunk{\effbox{\emptyset, \var{Abort}}\var{Int} \to
       \effbox{\varepsilon, \var{State}~\var{Int}}\var{Bool}} \to \effbox{\varepsilon}\var{Int}
\estack
\]

With the syntactic sugar in place, we can now avoid writing the effect
variable $\varepsilon$ ever. In addition, we need never write
$\emptyset$ in port effect sets. It is sometimes necessary to
explicitly write $\emptyset$ in peg effect sets. In particular, a pure
top-level program returning values of type $V$ has type
$\effbox{\emptyset}V$.





\section{Type system}
\label{sec:frank}


\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V          &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C             &::=& R \mid R \to C \\
\slab{returners}    &R             &::=& \effbox{\sigs}V
\\[1ex]
\slab{quantifiers}  &Z             &::=& X \mid \varepsilon \\
\slab{polytypes}    &P             &::=& \forall \many{Z}.Q \\
\slab{thunks}       &Q             &::=& \thunk{C}
\\[1ex]
\slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma        &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

Terms
\begin{syntax}
\slab{inferable values}&u       &::=& x \mid f \mid d                                \\
\slab{checkable values}&v        &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferable computations}&d &::=& \force{u} \mid d~e \mid c~\many{v}
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checkable computations} &e &::=& v \mid \many{r} \mapsto e \mid () \mid e \medvert e
\\[1ex]
\slab{value patterns}&p       &::=& x \mid k~\many{p}                              \\
\slab{computation patterns}&r &::=& p \mid \handle{c~\many{p}\,}{g} \mid \force{x} \\
\end{syntax}

\caption{Frank Syntax}
\label{fig:frank-syntax}
\end{figure}

The syntax of Frank types and terms is given in
Figure~\ref{fig:frank-syntax}. The types are divided into value types
and computation types in a similar fashion to Levy's
call-by-push-value calculus~\cite{Levy2004}.
%
Value types are data types ($D~\many{U}$), suspended $C$ computations
($\thunk{C}$), otherwise known as \emph{thunks}, or type variables
($X$).

Computation types are constructed from \emph{returners}.  A returner
$(\effbox{\sigs}V)$ represents the type of a computation that returns
values of type $V$ while performing effects in $\sigs$.
%
In general, computation types represent multi-handlers. The type
$\effbox{\sigs_1}V_1 \to \dots \to \effbox{\sigs_n}V_n \to
\effbox{\sigs}V$,
%
is the type of an $n$-handler. For each argument type
$\effbox{\sigs_i}V_i$ the multi-handler must handle effects in
$\sigs_i$ on that argument. Such an $n$-handler handles all of its
arguments simultanesouly. As a result of handling its arguments it
returns a value of type $V$ and may perform effects in $\sigs$.
%
We often write $\many{\effbox{\sigs}V} \to C$ as an abbreviation for
$\effbox{\sigs_1}V_1 \to \dots \to \effbox{\sigs_n}V_n \to C$.

Polytypes are restricted to thunks. Effect polymorphism is restricted
to a single effect variable $\varepsilon$, which in practice Frank
programmers need never write.

Data types and effect signatures are declared at the top-level. An
effect signature $S~\many{X}$ consists of a collection of command
declarations of the form $c:U(\many{V})$, denoting that command $c$
takes arguments of types $\many{V}$ and returns a value of type
$U$. The types $\many{V}$ and $U$ may all depend on $\many{X}$. Each
command many appear only once in a signature, and each command may
appear in only one signature.

An effect set is a sequence of signatures initiated either with the
empty effect $\emptyset$ (yielding a \emph{closed effect set}) or the
only effect variable $\varepsilon$ (yielding an \emph{open effect
  set}). Order is important, as repeats are permitted, in which case
the right-most signature overrides all others with the same name.

Shadowing arises naturally in two ways. First, given an open effect
set $\sigs$ we may substitute an arbitrary effect set for
$\varepsilon$. Second, we define a notion of effect extension: $\sigs
\oplus \sigs'$ is the \emph{extension} of effect set $\sigs$ with
closed effect set $\sigs'$, formally:
%
\[\ba{@{\sigs~\oplus~}l@{~}l@{}}
\emptyset               &= \sigs \\
(\sigs', \sig~\many{V}) &= (\sigs \oplus \sigs'), \sig~\many{V} \\
\ea\]

Type environments distinguish monomorphic and polymorphic variables.

Just as with the types, Frank terms are separated into value terms and
computation terms. Furthermore, as Frank has a bidirectional type
system~\cite{PierceT00}, the terms are further sub-divided into those
whose type is inferable, and those which may be checked against a
type.

Frank is less strict about the separation between value and
computation terms than call-by-push-value is. For instance, inferable
computations can sometimes be treated as inferable values. This is a
deliberate design decision, with the aim of making Frank convenient to
program with.

%%%%% Frank

\begin{figure*}[float]
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{R \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \many{Z}.Q \in \Gamma \\
   \dom(\theta) = \set{\many{Z}} \\
   \varepsilon \in \dom(\theta) \implies \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(Q)}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{U} \\ U = V}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\idoes{\Gamma}{C}{e} \\ e \text{ is complete for } C}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \idoesg{\effbox{\sigs \oplus \sigs'}V}{e}}
  {\can{\Gamma}{\sigs}{d~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs}
  {\cangs{c}{\many{\effbox{}V} \to \effbox{\sigs}U}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \many{Z}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\idoesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\idoesg{\effbox{\sigs}V}{v}}

\inferrule
  {\many{\sigs'} \text{ closed} \\
   (\pat{\effbox{\sigs'_i}V_i}{r_i}{\Delta_i})_i \\
   \idoes{\Gamma, \many{\Delta}}{C}{e}}
  {\idoesg{\many{\effbox{\sigs'}V} \to C}{\many{r} \mapsto e}}

\inferrule
  {V \text{uninhabited}}
  {\idoesg{\effbox{\sigs'}V \to C}{()}}

\inferrule
  {\idoesg{R \to C}{e} \\ \idoesg{R \to C}{e'}}
  {\idoesg{R \to C}{e \medvert e'}}
\end{mathpar}

$\boxed{\pat{V}{p}{\Delta}}$

\begin{mathpar}
\inferrule
  { }
  {\pat{V}{x}{x:V}}

\inferrule
  {k~\many{V} \in D~\many{U} \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{D~\many{U}}{k~\many{p}}{\many{\Delta}}}
\end{mathpar}

$\boxed{\pat{R}{r}{\Delta}}$

\begin{mathpar}
\inferrule
  {\pat{V}{p}{\Delta}}
  {\pat{\effbox{\sigs}V}{p}{\Delta}}

\inferrule
  {c:U(\many{V}) \in \sigs \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{\effbox{\sigs}V}
       {\handle{c~\many{p}}{g}}
       {\many{\Delta}, g:\thunk{\effbox{\emptyset}U \to \effbox{\sigs}V}}}

\inferrule
  { }
  {\pat{\effbox{\sigs}V}{\force{x}}{x:\thunk{\effbox{\sigs}V}}}
\end{mathpar}

\caption{Frank Typing Rules}
\label{fig:frank-typing}
\end{figure*}

The typing rules for Frank are given in Figure~\ref{fig:frank-typing}.
%
The judgement $\makesgs{u}{V}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferable value term $u$, then
we can infer that $u$ \emph{is} of type $V$.
%
The judgement $\hasgs{V}{v}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, value type $V$, and checkable
value term $v$, then we can check that $V$ \emph{has} $v$ as a valid term.
%
The judgement $\cangs{d}{C}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferable computation term $d$,
then we can infer that $d$ \emph{is} of type $C$.
%
The judgement $\idoesg{C}{e}$ says that given type environment
$\Gamma$, computation type $C$, and checkable computation term $e$,
then we can check that $C$ \emph{has} $e$ as a valid computation term.

The types of monomorphic variables ($x$) are simply looked up in the
type environment. The types of polymorphic variables ($f$) are looked
up and instantiated. In practice this means applying a simple
unification-based algorithm.
%
An inferable computation ($d$) is also an inferable value, providing
it is a returner whose effects agree with the ambient effects.

Any inferable value ($u$) is also checkable against its inferred
type. Data type ($k~\many{v}$) and thunk ($\thunk{e}$) terms are
checkable by checking their components. The side condition on the
thunk introduction rule requires that the pattern matching clauses of
$e$ be complete with respect to the type $C$ of $e$.

A thunk $u$ can by forced ($u!$) if its inferred type agrees with the
ambient effects. To infer the type of a handler application $d~e$, we
first infer the type of $d$, and then check that the argument matches
the inferred argument type. Note that the effect set on an argument
must be closed, and thus we may extend the ambient effect set with the
argument effect set when checking the argument.
%
The type of a command ($c$) is looked up from the ambient effects.
%
The term $\key{let}~x=d~\key{in}~d'$ binds the result of running $d$
in $d'$.
%
The term $\key{letrec}~\many{f : P = e}~\key{in}~d$ binds the mutually
recursive polymorphic functions $\many{f:P}$ in $d$.

Any term $v$ that type checks with ambient effects $\sigs$ at value
type $V$ also type checks at computation type $\effbox{\sigs}V$.
%
A multi-handler of type $\many{\effbox{\sigs'}V} \to C$ is built by
composing clauses of the form $\many{r} \mapsto e$, where $\many{r}$
is a sequence of \emph{computation patterns} whose variables are bound
in $e$.
%
The $e \medvert e'$ construct composes the clauses of $e$ with those
of $e'$. A multi-handler is defined by a collection of clauses that
provides complete coverage of the input types.
%
The $()$ construct allows empty sets of clauses to be constructed in
the event that the value type of a function argument is uninhabited.

We preclude composition of non-clauses (i.e. returners) by
constraining $e \medvert e'$ to have function type.
%
It is perfectly legitimate to compose clauses with different numbers
of arguments, though as a preliminary part of pattern matching
compilation, we first transform the program to ensure that all
composed clauses do have the same number of arguments.

Value patterns are standard, consisting of variable patterns ($x$) and
data type constructor patterns ($k~\many{p}$).

Computation patterns are more interesting. Any value pattern $p$ is
also a computation pattern (used to match against the value returned
by the returner computation).
%
A request pattern $\handle{c~\many{p}}{g}$ matches against a
computation of the form $\force{c}~\many{v}$ if the values $v$ match
against $p$. Furthermore, it also binds $g$ to the continuation of the
computation delimited by the nearest enclosing multi-handler. This is
where the real power of multi-handlers arises. A thunk pattern
$\force{x}$ matches any computation reifying it as a thunk bound to
$x$.





GIBBERISH






As is made apparent by the call-by-value translation in
Section~\ref{sec:feff}, Frank is morally a call-by-value language
(though multi-handlers complicate the picture somewhat).




Frank has a number of distinctive features.

Inspired by Levy's call-by-push-value (CBPV) calculus, Frank makes an
explicit distinction between computation and value types. However,
where CBPV also has a clear distinction between value terms and
computation terms, Frank is less rigid. The motivation for this design
is to reduce boilerplate in source programs. Frank combines the
advantages of CBPV, call-by-value (a la ML), and effect typing.

With future extensions for dependent types in mind, Frank adopts a
bidirectional typing discipline. A side-effect is that one cannot
write beta-redexes in Frank. We do not view this as a disadvantage.

Inspired by the observation that applying a function to a value is
equivalent to applying a handler to a pure computation, handlers and
functions are unified in Frank. Handlers are further generalised to
multi-handlers, which handle multiple computations simulataneously.

Frank provides a novel form of effect polymorphism, in which it is
never necessary to mention the names of effect variables.

We explain the semantics of Frank programs through a series of program
transformations.

First, we take a fairly standard approach to compiling away pattern
matching (Core Frank). As we may match simultaneously against multiple
side-effecting computations, we must be careful about
order. Optionally, we can expose non-exhaustive/incomplete pattern
matching as concrete effects.

Second, we make the distinction between values terms and computations
explicit, as in CBPV (\impeff).

Finally, we make polymorphism explicit. Our ultimate target is \feff,
an effect-polymorphic variant of Kammar et al's CBPV-inspired
lambda-eff calculus. The small-step semantics of \feff is a
straightforward variant of that of lambda-eff.


\section{Pattern matching compilation}
\label{sec:core}


Core Frank replaces multi-handlers with a combination of standard
call-by-value functions, case statements, and unary effect handlers.

The syntax of Core Frank is given in Figure~\ref{fig:core-syntax}.
%
\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V          &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C             &::=& R \mid V \to C \\
\slab{returners}    &R             &::=& \effbox{\sigs}V
\\[1ex]
\slab{quantifiers}  &Z             &::=& X \mid \varepsilon \\
\slab{polytypes}    &P             &::=& \forall \many{Z}.Q \\
\slab{thunks}       &Q             &::=& \thunk{C}
\\[1ex]
\slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
\slab{effects}      &\sigs         &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}
                    &\Gamma        &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

Terms
\begin{syntax}
\slab{inferable values}&u       &::=& x \mid f \mid d                                \\
\slab{checkable values}&v       &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferable computations}&d &::=& \force{u} \mid d~v \mid c~\many{v}
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checkable computations} &e  &::= & v \mid \lambda x.e \\
   &&\mid& \key{case}~u~\key{of}~
             (k~\many{x_k} \mapsto e_k)_k \\
   &&\mid& \key{handle}~d~\key{with}~
             \bstack
             (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
             \medvert~ x        \mapsto e \\
             \estack \\
\end{syntax}
\caption{Core Frank Syntax}
\label{fig:core-syntax}
\end{figure}
%
The Core Frank typing rules are given in Figure~\ref{fig:core-typing}.
%
\begin{figure*}[float]
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{V \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \many{Z}.Q \in \Gamma \\
   \dom(\theta) = \set{\many{Z}} \\
   \varepsilon \in \dom(\theta) \implies \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(Q)}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{U} \\ U = V}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\idoes{\Gamma}{C}{e}}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \has{\Gamma}{\sigs \oplus \sigs'}{V}{v}}
  {\can{\Gamma}{\sigs}{d~v}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs}
  {\cangs{c}{\many{V} \to \effbox{\sigs}U}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \many{Z}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\idoesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\idoesg{\effbox{\sigs}V}{v}}

\inferrule
  {\idoes{\Gamma, x:V}{C}{e}}
  {\idoesg{V \to C}{\lambda x.e}}

\inferrule
  {\makesgs{u}{D~\many{U}} \\
   \\ \effs{C}{\sigs} \\
   (\idoes{\Gamma, \many{x_k}:\many{V}}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
  {\idoesg{C}{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}}

\inferrule
  {\sigs' \text{ closed} \\
   \effs{C}{\sigs} \\
   \can{\Gamma}{\sigs \oplus \sigs'}{d}{\effbox{\sigs \oplus \sigs'}{V}} \\
   (\idoes{\Gamma, \many{x_c}:\many{V}, g_c:\thunk{U \to \effbox{\sigs \oplus \sigs'}{V}}}
         {C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
   \idoes{\Gamma, x:V}{C}{e}}
  {\idoes{\Gamma}
         {C}{\key{handle}~ d ~\key{with}~
               (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
                x \mapsto e}}
\end{mathpar}

\caption{Core Frank Typing Rules}
\label{fig:core-typing}
\end{figure*}


%% The syntax of Core Frank is given in Figure~\ref{fig:core-syntax}.

%% \begin{figure}
%% Types
%% \begin{syntax}
%% \slab{values}       &U, V   &::=& D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
%% \slab{computations} &C      &::=& \rt{V} \mid V \to C
%% \\[1ex]
%% \slab{polytypes}    &P      &::=& \forall \varepsilon \many{X}.Q \\
%% \slab{thunks}       &Q      &::=& \effbox{\sigs}\thunk{C}
%% \\[1ex]
%% \slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
%% \slab{effects}      &\sigs  &::=&
%%   \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
%% \\[1ex]
%% \slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \mid f:P \\
%% \end{syntax}

%% Terms
%% \begin{syntax}
%% \slab{inferable values}       &u  &::= & x \mid f \mid d                           \\
%% \slab{checkable values}       &v  &::= & u \mid k~\many{v} \mid \thunk{e}
%% \\[1ex]
%% \slab{inferable computations} &d  &::= & \force{u} \mid d~v \mid c~\many{v}
%%                                    \mid  \key{let}~x=d~\key{in}~d' \\
%%                               &   &\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
%% \slab{checkable computations} &e  &::= & v \mid \lambda x.e \\
%%   &&\mid& \key{case}~u~\key{of}~
%%             (k~\many{x_k} \mapsto e_k)_k \\
%%   &&\mid& \key{handle} ~d~ \key{with}
%%             \bstack
%%             ~~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
%%             \medvert~ x        \mapsto e \\
%%             \estack \\
%% \end{syntax}
%% \caption{Core Frank Syntax}
%% \label{fig:core-syntax}
%% \end{figure}


%% A superficial change to the types is that rather than annotating value
%% returning computations with effects, we shift such labels to the thunk
%% containing the computation. The former design seems more convenient to
%% program with, which is why we adopt it in the source language. The
%% latter design leads to a slightly more uniform presentation of the
%% type rules (the checking judgement for computations now has the same
%% shape as the checking judgement for values, and we no longer need the
%% $\judgeword{does}$ judgement).
%
%% The typing rules of Core Frank are given in
%% Figure~\ref{fig:core-syntax}.

%%%%% Core Frank

%% \begin{figure*}[float]
%% $\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
%% \begin{mathpar}
%% \inferrule
%%   {x:V \in \Gamma}
%%   {\makesgs{x}{V}}

%% %% \inferrule
%% %%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%% %%    \theta(\varepsilon) = \sigs}
%% %%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

%% \inferrule
%%   {f:\forall \varepsilon \many{X}.V \in \Gamma \\
%%    \dom(\theta) = \set{\varepsilon, \many{X}} \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makesgs{f}{\theta(V)}}

%% \inferrule
%%   {\cangs{d}{\rt{V}}}
%%   {\makesgs{d}{V}}
%% \end{mathpar}

%% $\boxed{\has{\Gamma}{\sigs}{V}{v}}$

%% \begin{mathpar}
%% \inferrule
%%   {\makesgs{u}{V}}
%%   {\hasgs{V}{u}}

%% \inferrule
%%   {(\hasgs{V_i}{v_i})_i \\
%%    k~\many{V} \in D~\many{U}}
%%   {\hasgs{D~\many{U}}{k~\many{v}}}

%% \inferrule
%%   {\does{\Gamma}{\sigs'}{C}{e}}
%%   {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
%% \end{mathpar}

%% $\boxed{\can{\Gamma}{\sigs}{d}{C}}$

%% \begin{mathpar}
%% \inferrule
%%   {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
%%   {\cangs{\force{u}}{C}}

%% \inferrule
%%   {\cangs{d}{V \to C} \\
%%    \has{\Gamma}{\sigs}{V}{v}}
%%   {\cangs{d~v}{C}}

%% \inferrule
%%   {c : U(\many{V}) \in \sigs \\
%%    (\hasgs{V_i}{v_i})_i}
%%   {\cangs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\cangs{d}{\effbox{\sigs}V} \\
%%    \can{\Gamma, x:V}{\sigs}{d'}{C}}
%%   {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

%% \inferrule
%%   {(\idoes{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{e_i}{Q_i})_i \\
%%    \can{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{d}{C}}
%%   {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.Q = e}~\key{in}~d}{C}}
%% \end{mathpar}

%% $\boxed{\doesgs{C}{e}}$

%% \begin{mathpar}
%% \inferrule
%%   {\hasgs{V}{v}}
%%   {\doesgs{\rt{V}}{v}}

%% \inferrule
%%   {\does{\Gamma, x:V}{\sigs}{C}{e}}
%%   {\doesgs{V \to C}{\lambda x.e}}

%% \inferrule
%%   {\makesgs{u}{D~\many{U}} \\
%%    (\does{\Gamma, \many{x_k}:\many{V}}{\sigs}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
%%   {\doesgs{C}{\key{case}~ u ~\key{of}~
%%                (k~\many{x_k} \mapsto e_k)_k}}

%% \inferrule
%%   {\sigs' \text{ closed} \\
%%    \can{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
%%    (\does{\Gamma, \many{x_c}:\many{V}, g_c:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
%%          {\sigs}{C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
%%    \does{\Gamma, x:V}{\sigs}{C}{e}}
%%   {\does{\Gamma}{\sigs}
%%          {C}{\key{handle}~ d ~\key{with}~
%%                (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
%%                 x \mapsto e}}
%% \end{mathpar}

%% \caption{Core Frank Typing Rules}
%% \label{fig:core-typing}
%% \end{figure*}

Multi-handlers in Frank become curried functions over suspended
computations in Core Frank.
%
Shallow pattern matching on a single request becomes unary effect
handling. Shallow pattern matching on a data type value becomes case
analysis. Nested pattern matching on multiple computations is realised
as a pattern matching tree constructed from handlers and case
statements. 

We may adapt standard algorithms for pattern matching compilation
apply~(e.g. \cite{Augustsson85} or \cite{Maranget08}). Rather than
comitting to a particular one, we outline how a pattern matching
compiler fits into our setting, what input it takes, and what kind of
output it must produce.

\begin{sloppypar}
Given a Frank expression $\thunk{e}$ such that $\idoesg{R_1 \dots R_n
  \to R}{e}$
%
we compile it to an equivalent Core Frank expression $\thunk{\pc{e}}$.
%
First we expand all of the clauses in $e$ to yield an $n$ column
pattern matrix. For instance, suppose the arguments have types
$\effbox{\var{Send~Char}, \var{Abort}}\var{Unit}$ and
$\effbox{\var{Receive~Char}}$, and we have the following clauses:
\end{sloppypar}
\[
\ba{@{}l@{~}l@{~}l@{}}
  (\handle{\var{send}~x}{s}) & (\handle{\var{receive}}{r}) & \mapsto e_1 \\
  (\handle{\var{send}~x}{s}) & z & \mapsto e_2 \\
  (\handle{\var{abort}}{s})  & e_3 \\
  \var{unit} & e_4 \\
\ea
\]
%
then this becomes:
%
\[
\ba{@{}l@{\quad}l@{~\mapsto~}l@{}}
  (\handle{\var{send}~x}{s}) & (\handle{\var{receive}}{r}) & e_1 \\
  (\handle{\var{send}~x}{s}) & z & e_2 \\
  (\handle{\var{abort}}{s})  & z & \var{bind}~x~e' \\
  \var{unit}                 & z & \var{bind}~z~e_4 \\
\ea
\]
%
Next we generate a vector of fresh variables, one for each argument.
\[
\ba{@{}l@{~}l@{}}
  x_0 & x_1
\ea
\]
The goal of pattern matching compilation is to generate a pattern
matching tree that matches the variable vector against all of the
patterns in the pattern matrix in the correct order.

In Frank, pattern matching trees $M$ are built up from leaves, case
analysis, and handlers.
%% \begin{equations}
%% M &::= & \many{e} \\
%%   &\mid& \key{case}~(x:D~\many{U})~\key{of}~(k~\many{x_k} \mapsto M_k)_{k \in D} \\
%%   &\mid& \key{handle}~(\force{x}:\effbox{\sigs}V)~\key{with}~
%%           (\handle{c~\many{x_c}}{g_c} \mapsto M_c)_{c \in \sigs} \medvert
%%           x        \mapsto M
%% \end{equations}%
\begin{equations}
M &::= & \many{e} \\
  &\mid& \key{case}~x~\key{of}~(k~\many{x_k} \mapsto M_k)_{k \in D} \\
  &\mid& \key{handle}~\force{x}~\key{with}~
          (\handle{c~\many{x_c}}{g_c} \mapsto M_c)_{c \in \sigs} \medvert
          x        \mapsto M
\end{equations}%
The leaves consist of a sequence of checkable computation
expressions. Each element corresponds to one way of matching all of
the patterns. If there exists a leaf with no elements, then the
pattern matching is incomplete; if there exists a leaf with multiple
elements, then the pattern matching is ambiguous.
%
Our default strategy (as indicated by the thunk introduction rule) is
to class incomplete pattern matching as a type error, and to keep only
the first element in the case of ambiguous pattern matching.
%
Our example generates the following pattern matching tree:
\[
M = \bstack
    \key{handle}~\force{x_0}~\key{with} \\
    \quad  \handle{\var{send}~x}{s} \mapsto \\
    \quad\quad \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad \handle{\var{receive}}{r} \mapsto e \\
    \quad\quad\quad z \mapsto e2 \\
    \quad  \handle{abort}{s} \mapsto \\
    \quad\quad \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad    \handle{receive}{r} \mapsto \var{bind}~(\force{r}~\force{receive})~e_3 \\
    \quad\quad\quad    z \mapsto \var{bind}~z~e_3 \\
    \quad  y \mapsto \\
    \quad\quad  \key{case}~y~\key{of} \\
    \quad\quad\quad  \var{unit} \mapsto \key{handle}~\force{x_1}~\key{with} \\
    \quad\quad\quad\quad    \handle{receive}{r} \mapsto \var{bind}~(\force{r}~\force{receive})~e_4 \\
    \quad\quad\quad\quad    z \mapsto \var{bind}~z~e_4 \\
\estack
\]
%
from which we obtain the corresponding Core Frank code by abstracting
over the fresh variables.
%
\[
\lambda x_0 x_1.M
\]
Some pattern matching operations reorder columns as an
optimisation. Column reordering is not in general a valid optimisation
in Frank. This is because commands in the ambient effects, but not in
the argument effects, are implicitly forwarded, and the order in which
they are forwarded is left-to-right. (The forwarding behaviour is made
precise in the Section~\ref{sec:semantics}.)

Of course, because Core Frank takes values as arguments whereas Frank
takes computations, each argument must be wrapped in a thunk
constructor.
%
The type translation is given simply by the homorphic extension of the
following equation on function types:
\begin{equations}
\pc{\effbox{\sigs}V} \to \pc{C} &=& \thunk{\effbox{\pc{\sigs}}\pc{V}} \to \pc{C} \\
\end{equations}

A correct pattern matching translation $\pc{-}$ from Frank to Core
Frank should be type preserving.
\begin{itemize}
\item If $\makesgs{u}{V}$ then $\makes{\pc{\Gamma}}{\pc{\sigs}}{\pc{u}}{\pc{V}}$.
\item If $\hasgs{V}{v}$   then $\has{\pc{\Gamma}}{\pc{\sigs}}{\pc{V}}{\pc{v}}$.
\item If $\cangs{d}{C}$   then $\can{\pc{\Gamma}}{\pc{\sigs}}{\pc{d}}{\pc{C}}$.
%%\item If $\idoesg{C}{e}$  then $\idoes{\pc{\Gamma}}{\pc{C}}{\pc{e}}$.
\end{itemize}

As an extension to Frank, we might allow incomplete and ambiguous
pattern matching. The former may be permitted if the ambient effects
contain the $\var{Abort}$ signature, in which case incomplete patterns
are translated into the $\var{abort}:\var{Zero}$ command, which can
then be handled however the programmer wishes. Simiarly, we can define
a $\var{choice}:X(X, X)$ command, in order to allow ambiguous pattern
matches to be handled by the programmer.

%% \begin{equations}
%% \pc{D~\many{U}) &=& D~\pc{\many{U}} \\
%% \pc{\thunk{C}}  &=& \thunk{\pc{C}} \\
%% \pc{X} &=& X
%% \\[1ex]
%% \pc{\effbox{\sigs}V} &=& \effbox{\pc{\sigs}}\pc{V} \\
%% \pc{\effbox{\sigs}V} \to \pc{C} &=& \thunk{\effbox{\pc{\sigs}}\pc{V}} \to \pc{C} \\
%% \\[1ex]
%% \pc{\emptyset} &=& \emptyset \\
%% \pc{\sigs, S~\many{V}} &=& \pc{\sigs}, S~\pc{\many{V} \\
%% \pc{\varepsilon} &=& \varepsilon \\
%% \\[1ex]
%% \pc{\cdot} &=& \cdot \\
%% \pc{c:U(\many{V}), S~\many{X}} &=& 
%% \end{equations}


\section{Explicit Control flow and Polymorphism}
\label{sec:feff}

In order to make control flow explicit, and to ease the definition of
an operational semantics, we translate Core Frank into a
call-by-push-value calculus \feff based on Kammar et al's
\lameff~\cite{KammarLO13}.

At the same time, we make polymorphism explicit. Broadly, \feff types
are similar to Frank types, with an explicit division between value
type and computation types. A superficial difference is that rather
than annotating value returning computations with effects, we shift
such labels to the thunk containing the computation. The former design
seems more convenient to program with, which is why we adopt it in the
source language. The latter design leads to a more uniform
presentation of the typing rules, and matches the design of \lameff.

Typing in \feff is unidirectional.
%
The syntax of \feff is given in Figure~\ref{fig:feff-syntax}. The
typing rules for \feff are given in Figure~\ref{fig:feff-typing}.

Call-by-push-value calculi such as \lameff and \feff make a strict
separation between values and computations, not dissimilar from CPS or
A-normal form representations, in which all reduction takes place at
the level of computations. In such a setting it would seem most
natural to add type abstractions to computations rather than
values. However, this does not give us what we need in the presence of
effects, as we need to be able to quantify over effects. Our solution
is to build the universal quantifier into the thunk type (the
introduction rule for thunks is the place where ambient effects are
reifed in a type) and build type application into forcing.

%% As we only allow top-level polymorphism, the translation from \impeff
%% to \feff is straightforward. Generalisation (type abstraction) only
%% occurs on top-level definitions, and instantiation (type application)
%% only occurs on top-level variable lookup.

The type translation from Core Frank to \feff is given by the
homomorphic extension of the following equations:
\begin{equations}
\sem{\thunk{C}} &=& \effbox{\sem{\sigs}}\thunk{\sem{C}}, \quad \text{where }\effs{C}{\sigs} \\
\sem{\effbox{\sigs}V \to C} &=& \effbox{\sem{\sigs}}\sem{V} \to \sem{C} \\
\sem{\effbox{\sigs}V} &=& \rt{\sem{V}}\\
\end{equations}
%
  %% drop ([Sig]{C}) = {drop(C) drop(Sig)}
  %%
  %% drop ( <V> ) Sig          = [ drop (Sig) ] drop(V)
  %% drop ( [Sig']V -> C ) Sig = [ drop (Sig') ] drop(V) -> drop(C) drop(Sig)
%
The term translation is a call by value embedding of Core Frank into
\feff:
%
\begin{equations}
\sem{x} &=& \key{ret}~x \\
\sem{f^{\sigs, \many{T}}} &=& f~\sem{\sigs}~\sem{\many{T}} \\
\\
\sem{k~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~\key{ret}~(k~\many{x}) \\
\sem{\thunk{e}} &=& \key{ret}~\thunk{\sem{e}} \\
\\
\sem{c~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~c~\many{x} \\
\sem{d~v} &=& \key{let}~x=\sem{v} ~\key{in}~d~x \\
\sem{\force{u}} &=& \key{let}~x=\sem{u} ~\key{in}~\force{x} \\
\\
\sem{\lambda x.e} &=& \lambda x.\sem{e} \\
\multicolumn{3}{@{}l}{\sem{\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{let}~x=\sem{u} ~\key{in}~
    \key{case}~x~\key{of}~(k~\many{x_k} \mapsto \sem{e_k})_k} \\
\multicolumn{3}{@{}l}{\sem{\key{handle}~d~\key{with}~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert x \mapsto e} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{handle}~\sem{d}~\key{with}~ 
            (\handle{c~\many{x_c}}{g_c} \mapsto \sem{e_c})_c
            \medvert x \mapsto \sem{e}} \\
\end{equations}%
%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {f:\forall \varepsilon \many{X}.V \in \Gamma \\
%%      \dom(\theta) = \set{\varepsilon, \many{X}} \\
%%      \theta(\varepsilon) = \sigs}
%%     {\makesgs{f}{\theta(V)}}
%% \semr \qquad \\[3ex]
%% \hfill = \force{(f~\sigs~\many{\theta(X)})} \\
%% \el
%% \]

\begin{proposition}
The translation $\sem{-}$ from Core Frank to \feff is type preserving.
\begin{itemize}
\item If $\makesgs{u}{V}$ then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{u}}{\rt{\sem{V}}}$.
\item If $\hasgs{V}{v}$   then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{v}}{\rt{\sem{V}}}$.
\item If $\cangs{d}{C}$   then $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{d}}{\sem{C}}$.
\item If $\idoesg{C}{e}$ and $\effs{C}{\sigs}$ then
  $\comp{\sem{\Gamma}}{\sem{\sigs}}{\sem{e}}{\sem{C}}$.
\end{itemize}
\end{proposition}


%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:V}{x}{\theta(V)}}
%% \semr
%% = \\
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:\forall \many{Z}.V}{x~\theta(\many{Z})}{\theta{V}}} \\
%% \el
%% \]


\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid \forall \many{Z}.\effbox{\sigs}\thunk{C} \mid X \\ % \mid \forall X.V \\
\slab{computations} &C      &::=& \rt{V} \mid V \to C  % \mid \forall X.C \\
\\[1ex]
\slab{quantifiers}  &Z      &::=& X \mid \varepsilon \\
\slab{arguments}    &T      &::=& V \mid \sigs
\\[1ex]
\slab{polytypes}    &P      &::=& \forall \many{Z}.Q \\
\slab{monothunks}   &Q      &::=& \effbox{\sigs}\thunk{C}
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \\
\end{syntax}

%% Effect extension
%% \begin{equations}
%% \sigs \oplus \emptyset               &=& \emptyset \\
%% \sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
%% \end{equations}

Terms
\begin{syntax}
\slab{values}       &u, v &::=& x \mid k~\many{v} \mid \thunk{d} \\
%%             \mid \Lambda Z.v \mid u~T \\
\slab{computations} &d, e &::=& \key{case}~u~\key{of}~
                                   (k~\many{x_k} \mapsto e_k)_k
                                \mid \force{(u~\many{T})} \\
                    &     &\mid& \lambda x.e \mid d~v 
                           \mid \key{ret}~v \mid \key{let}~x=e~\key{in}~e'
                           \mid c~\many{v} \\
%%   \mid \Lambda Z.e \mid d~T \\
                         &&\mid& \key{handle} ~d~ \key{with}~
                                   (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
                                   x        \mapsto e \\
                         &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~e' \\
\end{syntax}
\caption{\feff Syntax}
\label{fig:feff-syntax}
\end{figure}

\begin{figure*}
$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}
%% \inferrule
%%   {\valg{v}{V} \\
%%    Z \notin \FV(\Gamma)}
%%   {\valg{\Lambda Z.v}{\forall Z.V}}
%% \inferrule
%%   {\valg{u}{\forall Z.V}}
%%   {\valg{u~T}{V[T/Z]}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\forall \many{Z}.\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{(u~\many{T})}}{C[\many{T}/\many{Z}]}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {\compgs{d}{\rt{V}} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\key{let}~x=d~\key{in}~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\compgs{e}{C} \\
%%    Z \notin (\FV(\Gamma) \cup \FV(\sigs))}
%%   {\compgs{\Lambda Z.e}{\forall Z.C}}

%% \inferrule
%%   {\compgs{d}{\forall Z.C}}
%%   {\compgs{d~T}{V[T/Z]}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}

\inferrule
  {(\comp{\Gamma, \many{f : \forall\many{Z}.Q}}{\sigs}{e_i}{Q_i})_i \\
   \comp{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\compgs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

\caption{\feff Typing rules}
\label{fig:feff-typing}
\end{figure*}

\section{Small-step semantics}
\label{sec:semantics}

\begin{figure*}

\begin{equations}
%% (\textrm{Value contexts})\, D
%%   &::=& [~] \mid \key{case}~D~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i \mid \force{D} \mid D~T \\
(\textrm{Delimited computation contexts})\, D
  &::=& [~] \mid D~v \mid \key{let}~x=D~\key{in}~e \\
(\textrm{Computation contexts})\, E
  &::=& [~] \mid E~v \mid \key{let}~x=E~\key{in}~e
            \mid \key{handle}~E~\key{with}~H \\
               %% (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
               %%   x \mapsto e \\
\end{equations}%

\begin{equations}
%% (\Lambda Z.v) T &\reducesto& v[T/Z]
%% \\[1ex]
\key{case}~k_j~\many{v}~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i
  &\reducesto& e_j[\many{v}/\many{x_j}] \\
\force{\thunk{e}} &\reducesto& e
\\[1ex]
(\lambda x.e)~v &\reducesto& e[v/x] \\
%% (\key{rec}~f~x.e)~v &\reducesto& e[\thunk{\key{rec}~f~x.e}/f, v/x] \\
\key{let}~x=\key{ret}~v~\key{in}~e &\reducesto& e[v/x] \\
\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d
  &\reducesto&
    d[\many{\Lambda{Z}.\thunk{e}}
       [\many{\Lambda{Z}.
                \thunk{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~\force{(f~\many{Z})}}}
       / \many{f}]
     /\many{f}]
\\[1ex]
\key{handle}~(\key{ret}~v)~\key{with}~H
  &\reducesto& H(\key{ret}, v) \\
\key{handle}~D[c~\many{v}]~\key{with}~H
  &\reducesto& H(c, \many{v}, \thunk{\lambda z.D[\key{ret}~z]}) \\
%% \key{handle}~(\key{ret}~v)~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%     \key{let}~x=\key{ret}~v~\key{in}~e \\
%% \key{handle}~E[c_j~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      e_j[\many{v}/\many{x_j}, \thunk{\lambda z.E[\key{ret}~z]} / g] \\
%% \key{handle}~E[c~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      \key{let}~z=c~\many{v}~\key{in}~
%%        \key{handle}~E[\key{ret}~z]~\key{with}~
%%           (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%           x \mapsto e, \quad c \neq c_i \text{ for any }i \\
\end{equations}%
where the action of $H = (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert x
\mapsto e$ is given by:
\begin{equations}%
H(\key{ret}, v) &=& e[v/x] \\
H(\key{c_j}, \many{v}, u) &=& e_j[\many{v}/\many{x}, u/g] \\
H(\key{c}, \many{v}, u)
  &=& \key{let}~z=c~\many{v}~\key{in}~
        \key{handle}~\force{u}~z~\key{with}~H,
           \quad c \neq c_i\text{ for any }i
\end{equations}%

\begin{mathpar}
%% \inferrule
%%   {u \reducesto v}
%%   {D[u] \reducesto D[v]}

\inferrule
  {d \reducesto e}
  {E[d] \reducesto E[e]}
\end{mathpar}

\caption{Small-step operational semantics for \feff}
\label{fig:semantics}
\end{figure*}

\begin{proposition}[Type Soundness]
~
\begin{itemize}
\item If $\compgs{d}{C}$ and $d \reducesto e$ then $\compgs{e}{C}$.
\item If $\comp{\cdot}{\emptyset}{d}{\rt{V}}$ then either there exists $v$
  such that $d = \key{ret}~v$ or there exists $e$ such that $d \reducesto
  e$.
\end{itemize}
\end{proposition}

\section{Related work}
\label{sec:related}


\section{Conclusion and future work}
\label{sec:conclusion}


%% \begin{abstract}
%% This is the text of the abstract.
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keys
%% keyword1, keyword2

%% \section{Introduction}

%% The text of the paper begins here.

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{frankly}

% The bibliography should be embedded for final submission.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\end{document}

Rubbish
-------


sig ReadLine
  = peek : Char
  | nom  : 0

sig Abort
  = aborting : 0

if Bool then {X} else {X} -> X
if tt then t else f = t!
if ff then t else f = f!

0 >> Y [] Y


map {X -> Y} (List X)   []   List Y

top-level functions:

       V == forall Z*.V
  P -> C == {P -> C}

Anywhere:

    V == [e]V
   [] == [e]



d e == d ! e




  P [Sig] V == P -> [Sig]V


 

Push sigs inside:

  [[ [Sig]{C} ]] = [[C]] Sig

  [[ <V> ]] Sig          = [ [[Sig]] ] [[V]]
  [[ [Sig']V -> C ]] Sig = [ [[Sig']] ] [[V]] -> [[C]] Sig

Pull sigs outside:

  [[ {C} ]] = [ ((C)) ]{ [[ C ]]}

  [[ [Sig]V -> C )) = [ [[Sig]] ]V -> [[C]]
  [[ [Sig]V ]]      = < [[V]] >

  (( [Sig]V -> C )) = ((C))
  (( [Sig]V ))      = [[Sig]]

foo : Int
foo = 3

map : {X [] Y} (List X) [] List Y


letrec
  map : forall e X Y.{[0]{[0]X -> [e]Y} [0](List X) -> [e](List Y)}
  map f nil         = nil
  map f (cons x xs) = cons (f x) (map f xs)
in
  e

letrec
  map : (X -> Y) -> List X -> List Y
  map f nil         = nil
  map f (cons x xs) = cons (f x) (map f xs)
in
  e

  

map : forall e X Y.{{[e]X -> <Y>}[e] [e](List X) -> [e](List Y)}[e]



map : forall e X Y.{[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[ ]{[ ]X -> [ ]Y} [ ](List X) -> [ ](List Y)}
map :              {   {   X ->    Y}    (List X) ->    (List Y)}
map :                  {   X ->    Y}    (List X) ->    (List Y)


map : forall e X Y.[e]{[e]([e]{[e]X -> <Y>}) [e](List X) -> <List Y>}



map :              [e]{[e]{[e]X -> <Y>} [e](List X) -> <List Y>}
map :                 {   {   X -> <Y>}    (List X) -> <List Y>}
map :                     {   X -> <Y>}    (List X) -> <List Y>
map :                     {   X ->  Y }    (List X) ->  List Y

map : {X -> Y} (List X) -> List Y
map f nil        = nil
map f (x :: xs)  = f x :: map f xs


main [Console] List ()

main forall e.[e, Console] {<List ()>}
main          [e, Console] {<List ()>}
main          [   Console] {<List ()>}
main          [   Console]   List ()
main = map ouch ('h' :: ('e' :: ('l' :: ('l' :: ('o' :: nil)))))
