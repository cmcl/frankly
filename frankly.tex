\documentclass[preprint]{sigplanconf}

% US Letter page size
%\pdfpagewidth=8.5in
%\pdfpageheight=11in


% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{xspace}

\newcommand{\lameff}{$\lambda_\mathrm{eff}$\xspace}
\newcommand{\feff}{$F_\textrm{eff}$\xspace}
\newcommand{\impeff}{Implicit \lameff}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\many}{\overline}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}

\newcommand{\seml}{\left\llbracket}
\newcommand{\semr}{\right\rrbracket}

\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}


\newcommand\ba{\begin{array}}
\newcommand\ea{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newcommand{\bstack}{\begin{array}[t]{@{}l@{}}}
\newcommand{\estack}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newenvironment{syntax}{\[\ba{@{}l@{~}r@{~}c@{~}l@{}}}{\ea\]}


\newcommand{\judgeword}[1]{~\mathbf{#1}~}

%\renewcommand{\sig}{\Sigma}
%\renewcommand{\sigs}{\Sigma s}
\newcommand{\sigentails}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\text{-\!-}}\,}

\newcommand{\sigmodels}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\mathord{=}}\,}


% \newcommand{\sigentails}[1]{\vdash_{#1}}

\newcommand{\val}[3]  {#1 \vdash {#2} : {#3}}
\newcommand{\comp}[4]  {#1 \sigentails{#2} {#3} : {#4}}

\newcommand{\rt}[1]{\langle{#1}\rangle}   % returner type

\newcommand{\valg}{\val{\Gamma}}
\newcommand{\compgs}{\comp{\Gamma}{\sigs}}

\newcommand{\is}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}

\newcommand{\makes}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\has}[4] {#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\can}[4]{#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\does}[4]{#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\idoes}[3]{#1 \vdash {#2} \judgeword{has} {#3}}

\newcommand{\effs}[2]{{#1} \judgeword{does} {#2}}

\newcommand{\pat}[3]{{#1} \judgeword{matches} {#2} \dashv #3}
\newcommand{\patg}[2]{\pat{#1}{#2}{\Gamma}}


\newcommand{\isgs}{\is{\Gamma}{\sigs}}

\newcommand{\makesgs}{\makes{\Gamma}{\sigs}}
\newcommand{\hasgs}{\has{\Gamma}{\sigs}}
\newcommand{\cangs}{\can{\Gamma}{\sigs}}
\newcommand{\doesgs}{\does{\Gamma}{\sigs}}
\newcommand{\idoesg}{\idoes{\Gamma}}

\newcommand{\sig}{S}
\newcommand{\sigs}{\Sigma}

%% \newcommand{\sig}{\Sigma}
%% \newcommand{\sigs}{E}


\newcommand{\X}{X}  % a type variable

\newcommand{\E}{E}  % the effect variable

\newcommand{\U}{U}
\newcommand{\V}{V}
\newcommand{\Us}{\many{\U}}
\newcommand{\Vs}{\many{\V}}

\newcommand{\C}{C}

\newcommand{\tm}{t}
\newcommand{\tu}{u}
\newcommand{\tms}{\many{\tm}}
\newcommand{\tus}{\many{\tu}}

\newcommand{\p}{p}
\newcommand{\ps}{\many{\p}}

\newcommand{\h}{h}

\newcommand{\op}{\mathit{op}}

\newcommand{\effbox}[1]{[#1]}
\newcommand{\ret}[2]{\effbox{#1}{#2}}
\newcommand{\template}[3]{{#1} \mathbin{\effbox{#2}} {#3}}

\newcommand{\key}[1]{\mathsf{#1}}

\newcommand{\handleSymbol}{\mathbin{?}}
\newcommand{\yieldSymbol}{\mathbin{\prec}}
\newcommand{\continueSymbol}{\mathbin{\triangleleft}}
\newcommand{\handleType}[3]{\effbox{{#1} \yieldSymbol \ret{#2}{#3}}}
\newcommand{\handleTypePoly}[2]{\effbox{{#1} \yieldSymbol #2}}
\newcommand{\handleRet}[1]{\effbox{#1}}
\newcommand{\handleOp}[2]{\effbox{{#1} \continueSymbol {#2}}}
\newcommand{\handle}[2]{{#1} \handleSymbol {#2}}

\newcommand{\handleGen}[2]{\key{handle}~{#1}~\key{with}~{#2}}

\newcommand{\thunk}[1]{\{{#1}\}}
%\newcommand{\athunk}[2]{\thunk{#1}_{#2}}
\newcommand{\athunk}[2]{[#2]\thunk{#1}}

\newcommand{\force}[1]{{#1}!}
\newcommand{\app}{\mathbin{\text{@}}}

\newcommand{\con}{K}
\newcommand{\D}{D}

\newcommand{\args}{\mathit{args}}

\newcommand{\rplus}{\mathbin{\mathord{+}\!\!\!\!\mathord{\shortrightarrow}}}
\newcommand{\lplus}{\mathbin{\mathord{+}\!\!\!\!\!\mathord{\shortleftarrow}}}


\newcommand{\VV}{\mathbb{V}}
\newcommand{\VVs}{\many{\VV}}
\newcommand{\CC}{\mathbb{C}}

\newcommand{\inst}[2]{\mathit{inst}({#1}, {#2})}
\newcommand{\instt}[1]{\inst{\theta}{#1}}

%% \newcommand{\oldinst}[3]{\mathit{inst}({#1},{#2},{#3})}
%% \newcommand{\oldinstts}[1]{\oldinst{\theta}{\sigs}{#1}}

%% \newcommand{\appsig}[2]{{#1}\mathord{\cdot}{#2}}


\newcommand\slab[1]{(\textrm{#1})}


\begin{document}

%% \conferenceinfo{WXYZ '05}{date, City.} 
%% \copyrightyear{2005} 
%% \copyrightdata{[to be supplied]} 

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Do Be Do Be Do}
%% \subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}
           {The University of Edinburgh}
           {}
\authorinfo{Conor McBride}
           {University of Strathclyde}
           {}
%%         {Email1}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle

%% Structure:

%%   Introduction
%%   Examples
%%     parsing
%%     pipes
%%     ...
%%   Frank syntax and type system (source language)
%%     semantics by elaboration into successively simpler languages
%%   pattern matching compilation
%%     option to expose incomplete/ambiguous pattern matching as
%%     concrete effects
%%   CBPV
%%   Explicit polymorphism
%%   Small-step semantics (see handlers in action)
%%
%%   Related work
%%
%%     Plotkin+Power, Plotkin+Pretnar, Hancock, Eff, Brady, Kiselyov
%%     et al, Felleisen, Kammar et al, Filinski, Koka, Ahmen+Plotkin,
%%     Staton, Kleisli arrows of outrageous fortune, data types a la carte
%%
%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules

\section{Introduction}

This paper explores the design of Frank, a strict functional
programming language designed from the ground up around a novel
variant of Plotkin and Pretnar's \emph{effect
  handler}~\cite{PlotkinP09, PlotkinP13} abstraction.

In Frank, effect handlers strictly generalise functions. In the
general case an effect handler acts as an interpreter for a finite set
of commands whose signatures are statically tracked by the type
system. A function is the special case of an effect handler that
interprets the empty set of commands.

The main contributions of this paper are:
\begin{itemize}
\item Frank, a functional programming language featuring a
  bidirectional effect type system, effect polymorphism, and effect
  handlers.
\item A novel approach to effect polymorphism which avoids all mention
  of effect variables, crucially relying on the observation that one
  must always instantiate the effects of a function being applied with
  the current \emph{ambient} effects.
\item The combination of pattern matching and effect handlers in such
  a way that incomplete or ambiguous pattern matching can be realised
  as concrete effects that can be handled however the programmer
  chooses using further effect handlers.
\item A characterisation of effect-handlers as generalised functions.
\item Multi-handlers for handling multiple computations over different
  effect sets synchronously.
\item A type system for Frank.
\item A series of type preserving translations from Frank into
  successively more canonical type systems, culminating in \feff a
  polymorphic variant of the lambda-eff calculus of Kammar et al,
  which in turn is an extension of Levy's call-by-push-value
  calculus~\cite{Levy2004}.
\item A straightforward small-step operational semantics for \feff,
  yielding, in combination with the translations to \feff, a type
  soundness result for Frank.
\end{itemize}

A number of other languages and libraries are built around effect
handlers and algebraic effects.

Bauer and Pretnar's Eff~\cite{BauerP12}. A significant difference
between Frank and the original version of Eff~\cite{BauerP12} is that
the latter provides no support for effect typing. Recently Bauer and
Pretnar have designed an effect type system for
Eff~\cite{BauerP13}. Their implementation~\cite{Pretnar13} supports
Hindley-Milner type inference, and the type system incorporates effect
sub-typing. In contrast, Frank uses bidirectional type inference, and
avoids sub-typing altogether.

Handlers in action~\cite{KammarLO13}. In previous work with Kammar and
Oury~\cite{KammarLO13}, the first author designed and experimented
with a number of effect handler libraries for languages ranging from
Racket, to SML, to Haskell. Apart from the Haskell library, our other
libraries have no effect typing support. The Haskell library takes
advantage of type classes to simulate an effect type system not
entirely dissimilar to that of Frank. As Haskell is lazy, the Haskell
library cannot be used to write direct-style effectful programs - one
must instead adopt a monadic style. Furthermore, although there are a
number of ways of almost simulating effect type systems in Haskell,
none is without its flaws. Kiselyov et al~\cite{KiselyovSS13} have
designed a similar Haskell library for effect handlers, making
slightly different design choices.

Brady~\cite{Brady13} has designed a library and DSL for programming
with effects in his dependently typed Idris language. Like the Haskell
libraries, Brady's library currently requires the programmer to write
effectful code in a monadic style.

The first author has been plotting Frank since
2007~\cite{McBride07}. He has implemented a prototype of a previous
version of Frank~\cite{McBride12}. The design described in the current
paper has much in common with that implementation, but there are some
syntactic and semantic differences. The most important change in the
current design is the introduction of multi-handlers as a
generalisation of both functions and handlers.

The rest of the paper is structured as follows.
%
Section~\ref{sec:examples} introduces Frank by
example. Section~\ref{sec:frank} presents a type system for
Frank. Sections~\ref{sec:core}, \ref{sec:impeff} and \ref{sec:feff}
describes a series of program translations targetting successively
more explicit type systems, culminating in \feff, a variant of Kammar
et al's \lameff calculus. Section~\ref{sec:semantics} gives a
semantics for \feff, which when composed with all of the program
translations, yields a semantics for Frank. Section~\ref{sec:related}
outlines related work and Section~\ref{sec:conclusion} concludes.


\section{Examples}
\label{sec:examples}

\subsection{Pipes}

\subsection{Modular rollback}

\subsection{Effect polymorphism with an invisible effect variable}


\section{The source language (Frank)}
\label{sec:frank}

The syntax of Frank types and terms is given in
Figure~\ref{fig:frank-syntax}. The types are divided into value types
and computation types in a similar fashion to Levy's
call-by-push-value calculus~\cite{Levy2004}.
%
Value types are data types ($D~\many{U}$), suspended $C$ computations
($\thunk{C}$), otherwise known as \emph{thunk types}, or type
variables ($X$).
%
Computation types are \emph{multi-handler} types. The type
$\effbox{\sigs_1}V_1 \to \dots \to \effbox{\sigs_n}V_n \to \effbox{\sigs}V$,
%
is the type of an $n$-handler. Each argument type
$\effbox{\sigs_i}V_i$ represents a computation returning values of
types $V_i$ such that the multi-handler must handle effects in
$\sigs_i$. Such an $n$-handler handles all of its arguments
together. As a result of handling its arguments it returns a value of
type $V$ and may perform effects in $\sigs$.

Polytypes are restricted to thunks. Effect polymorphism is restricted
to a single effect variable $\varepsilon$, which in practice Frank
programmers will never need to write.

As is commonplace for ML-like languages, data types are parameterised
and declared at the top-level. Analogously, effect signatures are also
parameterised and declared at the top-level. An effect signature
$S~\many{X}$ consists of a collection of command declarations of the
form $c:U{\many{V}}$ denoting that command $c$ takes arguments of
types $\many{V}$ and returns a value of type $U$, such that the
$\many{V}$ and $U$ may all depend on $\many{X}$. Each command can only
be declared once in a one signature.

A effect set is a sequence of signatures initiated either with the
empty effect $\emptyset$ (yielding a \emph{closed effect set}) or the only
effect variable $\varepsilon$ (yielding an \emph{open effect set}). Order
is important, as repeats are permitted, in which case the right-most
signature overrides all others with the same name.

Shadowing arises naturally in two ways. First, given an open effect
set $\sigs$ we may substitute an arbitrary effect set for
$\varepsilon$. Second, we define a notion of effect extension: $\sigs
\oplus \sigs'$ is the \emph{extension} of effect set $\sigs$ with
closed effect set $\sigs'$, formally:
%
\[\ba{@{\sigs~\oplus~}l@{~}l@{}}
\emptyset               &= \sigs \\
(\sigs', \sig~\many{V}) &= (\sigs \oplus \sigs'), \sig~\many{V} \\
\ea\]

In type environments, we distinguish monomorphic and polymorphic
variables.

Just as with the types, Frank terms are separated into value terms and
computation terms. Furthermore, as Frank has a bidirectional type
system~\cite{bidirectional-typing}, the terms are further sub-divided
into those whose type is inferrable, and those which may be checked
against a type.

Frank is less strict about the separation between value and
computation terms than call-by-push-value is. For instance, inferred
computations can sometimes be treated as inferred values. This is a
deliberate design decision, in order to make Frank convenient to
program with.

The typing rules for Frank are given in Figure~\ref{fig:frank-typing}.
%
The judgement $\makesgs{u}{V}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferrable value term $u$,
then we can infer that $u$ is of type $V$.
%
The judgement $\hasgs{V}{v}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, value type $V$, and checkable
value term $v$, then we can check that $V$ has $v$ as a valid term.
%
The judgement $\cangs{d}{C}$ says that given type environment
$\Gamma$, ambient effects $\sigs$, and inferrable computation term $d$,
then we can infer that $d$ is of type $C$.
%
The judgement $\idoesg{C}{e}$ says that given type environment
$\Gamma$, computation type $C$, and checkable computation term $e$,
then we can check that $C$ has $e$ as a valid computation term.

Monomorphic variable ($x$) are simply looked up in the type
environment. Polymorphic variables ($f$) are looked up and
instantiated. In practice this means performing unification.
%
An inferrable computation ($d$) is also an inferrable value, providing
it is a returner whose effects agree with the ambient effects.

Any inferrable value ($u$) is also checkable against its inferred
type. Data type ($k~\many{v}$) and thunk ($\thunk{e}$) terms are
checkable by checking their components.

A thunk $u$ can by forced ($u!$) if its inferred type agrees with the
ambient effects. To infer the type of a handler application $d~e$, we
first infer the type of $d$, and then check that the argument matches
the inferred argument type. Note that the effect set on an argument
must be closed, and thus we extend the ambient effect set with the
argument effect set when checking the argument.
%
The type of a command invocation ($c~\many{v}$) is looked up from the
ambient effects. We also check that the arguments match the argument
types.
%
Let, letrec. ...

Checking computations...

Patterns...




Inferred values consist of variables 






As is made apparent by the call-by-value translation in
Section~\ref{sec:impeff}, Frank is morally a call-by-value language
(though multi-handlers complicate the picture somewhat).




Frank has a number of distinctive features.

Inspired by Levy's call-by-push-value (CBPV) calculus, Frank makes an
explicit distinction between computation and value types. However,
where CBPV also has a clear distinction between value terms and
computation terms, Frank is less rigid. The motivation for this design
is to reduce boilerplate in source programs. Frank combines the
advantages of CBPV, call-by-value (a la ML), and effect typing.

With future extensions for dependent types in mind, Frank adopts a
bidirectional typing discipline. A side-effect is that one cannot
write beta-redexes in Frank. We do not view this as a disadvantage.

Inspired by the observation that applying a function to a value is
equivalent to applying a handler to a pure computation, handlers and
functions are unified in Frank. Handlers are further generalised to
multi-handlers, which handle multiple computations simulataneously.

Frank provides a novel form of effect polymorphism, in which it is
never necessary to mention the names of effect variables.

We explain the semantics of Frank programs through a series of program
transformations.

First, we take a fairly standard approach to compiling away pattern
matching (Core Frank). As we may match simultaneously against multiple
side-effecting computations, we must be careful about
order. Optionally, we can expose non-exhaustive/incomplete pattern
matching as concrete effects.

Second, we make the distinction between values terms and computations
explicit, as in CBPV (\impeff).

Finally, we make polymorphism explicit. Our ultimate target is \feff,
an effect-polymorphic variant of Kammar et al's CBPV-inspired
lambda-eff calculus. The small-step semantics of \feff is a
straightforward variant of that of lambda-eff.


\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V          &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C             &::=& R \mid R \to C \\
\slab{returners}    &R             &::=& \effbox{\sigs}V
\\[1ex]
\slab{polytypes}    &P             &::=& \forall \varepsilon \many{X}.Q \\
\slab{thunks}       &Q             &::=& \thunk{C}
\\[1ex]
\slab{signatures}   &\sig~\many{X} &::=& \cdot \mid c : U(\many{V}), \sig~\many{X} \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma        &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

Terms
\begin{syntax}
\slab{inferred values}&u       &::=& x \mid f \mid d                                \\
\slab{checked values}&v        &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferred computations}&d &::=& \force{u} \mid d~e \mid c~\many{v}
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checked computations} &e &::=& v \mid \many{r} \mapsto e \mid e \medvert e
\\[1ex]
\slab{value patterns}&p       &::=& x \mid k~\many{p}                              \\
\slab{computation patterns}&r &::=& p \mid \handle{c~\many{p}\,}{g} \mid \force{x} \\
\end{syntax}

\caption{Frank Syntax}
\label{fig:frank-syntax}
\end{figure}

%%%%% Frank

\begin{figure*}[float]
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{R \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.\thunk{C} \in \Gamma \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(\thunk{C})}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{V}}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\idoes{\Gamma}{C}{e}}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \idoesg{\effbox{\sigs \oplus \sigs'}V}{e}}
  {\can{\Gamma}{\sigs}{d~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{\rt{V}} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\idoesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\idoesg{\effbox{\sigs}V}{v}}

\inferrule
  {\many{\sigs'} \text{ closed} \\
   (\pat{\effbox{\sigs'_i}V_i}{r_i}{\Delta_i})_i \\
   \idoes{\Gamma, \many{\Delta}}{C}{e}}
  {\idoesg{\many{\effbox{\sigs'}V} \to C}{\many{r} \mapsto e}}

\inferrule
  {\idoesg{C}{e} \\ \idoesg{C}{e'}}
  {\idoesg{C}{e \medvert e'}}
\end{mathpar}

$\boxed{\pat{V}{p}{\Delta}}$

\begin{mathpar}
\inferrule
  { }
  {\pat{V}{x}{x:V}}

\inferrule
  {k~\many{V} \in D~\many{U} \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{D~\many{U}}{k~\many{p}}{\many{\Delta}}}
\end{mathpar}

$\boxed{\pat{R}{r}{\Delta}}$

\begin{mathpar}
\inferrule
  {\pat{V}{p}{\Delta}}
  {\pat{\effbox{\sigs}V}{p}{\Delta}}

\inferrule
  {c:U(\many{V}) \in \sigs \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{\effbox{\sigs}V}
       {\handle{c~\many{p}}{g}}
       {\many{\Delta}, g:\thunk{\effbox{\emptyset}U \to \effbox{\sigs}V}}}

\inferrule
  { }
  {\pat{\effbox{\sigs}V}{\force{x}}{x:\thunk{\effbox{\sigs}V}}}
\end{mathpar}

\caption{Frank Typing Rules}
\label{fig:frank-typing}
\end{figure*}

\section{Pattern matching compilation (Core Frank)}
\label{sec:core}


Core Frank replaces multi-handlers with a combination of standard
call-by-value functions, case statements, and unary effect handlers.

A superficial change to the types is that rather than annotating value
returning computations with effects, we shift such labels to the thunk
containing the computation. The former design seems more convenient to
program with, which is why we adopt it in the source language. The
latter design leads to a slightly more uniform presentation of the
type rules (the checking judgement for computations now has the same
shape as the checking judgement for values, and we no longer need the
$\judgeword{does}$ judgement).

Multi-handlers in Frank become curried function over suspended
computations.

Shallow pattern matching on a single request becomes unary effect
handling. Shallow pattern matching on a data type value becomes case
analysis. Nested pattern matching on multiple computations is realised
as a pattern matching tree constructed from handlers and case
statements. Standard algorithms for pattern matching compilation
apply. 

It may be instructive to observe the representation of the core
language handler and case constructs in the source language.

\[
\ba{@{}l@{}}
\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k
  \equiv
    \key{let}~h = \thunk{\!\!\mathord{\medvert}_{\!\!k} (k~\many{x_k} \mapsto e_k)}~\key{in}~h~u \\
\key{handle} ~d~ \key{with}~
           (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
            x        \mapsto e
  \equiv \\
\qquad
     \key{let}~h = \thunk{\!\!\medvert_{\!\!c} (\handle{c~\many{x_c}}{g_c} \mapsto e_c) \medvert x \mapsto e}
     ~\key{in}~h~d
\ea
\]

\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
\slab{computations} &C      &::=& \rt{V} \mid V \to C
\\[1ex]
\slab{polytypes}    &P      &::=& \forall \varepsilon \many{X}.Q \\
\slab{thunks}       &Q      &::=& \effbox{\sigs}\thunk{C}
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

%% Effect extension
%% \begin{equations}
%% \sigs \oplus \emptyset               &=& \sigs \\
%% \sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
%% \end{equations}

Terms
\begin{syntax}
\slab{inferred values}       &u  &::= & x \mid f \mid d                           \\
\slab{checked values}        &v  &::= & u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferred computations} &d  &::= & \force{u} \mid d~v \mid c~\many{v}
                                  \mid  \key{let}~x=d~\key{in}~d' \\
                             &   &\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\slab{checked computations}  &e  &::= & v \mid \lambda x.e \\
  &&\mid& \key{case}~u~\key{of}~
            (k~\many{x_k} \mapsto e_k)_k \\
  &&\mid& \key{handle} ~d~ \key{with}
            \bstack
            ~~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
            \medvert~ x        \mapsto e \\
            \estack \\
\end{syntax}
\caption{Core Frank Syntax}
\label{fig:core-syntax}
\end{figure}

%%%%% Core Frank

\begin{figure*}[float]
$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Gamma \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(V)}}

\inferrule
  {\cangs{d}{\rt{V}}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{V}}
  {\hasgs{V}{u}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{\sigs'}{C}{e}}
  {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{V \to C} \\
   \has{\Gamma}{\sigs}{V}{v}}
  {\cangs{d~v}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\rt{U}}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{e_i}{Q_i})_i \\
   \can{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\doesgs{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesgs{\rt{V}}{v}}

\inferrule
  {\does{\Gamma, x:V}{\sigs}{C}{e}}
  {\doesgs{V \to C}{\lambda x.e}}

\inferrule
  {\makesgs{u}{D~\many{U}} \\
   (\does{\Gamma, \many{x_k}:\many{V}}{\sigs}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
  {\doesgs{C}{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}}

\inferrule
  {\sigs' \text{ closed} \\
   \can{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\does{\Gamma, \many{x_c}:\many{V}, g_c:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
         {\sigs}{C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
   \does{\Gamma, x:V}{\sigs}{C}{e}}
  {\does{\Gamma}{\sigs}
         {C}{\key{handle}~ d ~\key{with}~
               (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
                x \mapsto e}}
\end{mathpar}

\caption{Core Frank Typing Rules}
\label{fig:core-typing}
\end{figure*}


\section{\lameff with implicit polymorphism}
\label{sec:impeff}

\begin{figure}[float]
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid \effbox{\sigs}\thunk{C} \mid X \\
\slab{computations} &C      &::=& \rt{V} \mid V \to C
\\[1ex]
\slab{polytypes}    &P      &::=& \forall \varepsilon \many{X}.Q \\
\slab{thunks}       &Q      &::=& \effbox{\sigs}\thunk{C}
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \mid f:P \\
\end{syntax}

%% Effect extension
%% \begin{equations}
%% \sigs \oplus \emptyset               &=& \sigs \\
%% \sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
%% \end{equations}

Terms
\begin{syntax}
\slab{values}         &u, v &::=& x \mid f \mid k~\many{v} \mid \thunk{d}  \\
\slab{computations}   &d, e &::=& \key{case}~u~\key{of}~
           (k~\many{x_k} \mapsto e_k)_k  \mid \force{u} \\
    &&\mid& \lambda x.e \mid d~v
      \mid  \key{ret}~v \mid c~\many{v} \\
    &&\mid& \key{handle} ~d~ \key{with}~
              (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
              x        \mapsto e \\
    &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~d \\
\end{syntax}
\caption{\impeff Syntax}
\label{fig:impeff-syntax}
\end{figure}

%%%%% Implicit lam-eff

\begin{figure*}[float]
$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\val{\Gamma, x:V}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Gamma \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\valg{f}{\theta(V)}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{u}}{C}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}

\inferrule
  {(\comp{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{e_i}{Q_i})_i \\
   \comp{\Gamma, \many{f : \forall \varepsilon \many{X}.Q}}{\sigs}{d}{C}}
  {\compgs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

\caption{\impeff Typing rules}
\label{fig:impeff-typing}
\end{figure*}


Call by value embedding of Core Frank into \impeff:

\begin{equations}
\sem{x} &=& \key{ret}~x \\
\\
\sem{k~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~\key{ret}~(k~\many{x}) \\
\sem{\thunk{e}} &=& \key{ret}~\thunk{\sem{e}} \\
\\
\sem{c~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~c~\many{x} \\
\sem{d~v} &=& \key{let}~x=\sem{v} ~\key{in}~d~x \\
\sem{\force{u}} &=& \key{let}~x=\sem{u} ~\key{in}~\force{x} \\
\\
\sem{\lambda x.e} &=& \lambda x.\sem{e} \\
\multicolumn{3}{@{}l}{\sem{\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{let}~x=\sem{u} ~\key{in}~
    \key{case}~x~\key{of}~(k~\many{x_k} \mapsto \sem{e_k})_k} \\
\multicolumn{3}{@{}l}{\sem{\key{handle}~d~\key{with}~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert x \mapsto e} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{handle}~\sem{d}~\key{with}~ 
            (\handle{c~\many{x_c}}{g_c} \mapsto \sem{e_c})_c
            \medvert x \mapsto \sem{e}} \\
\end{equations}

~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\
~\\



\section{Explicit polymorphism (\feff)}
\label{sec:feff}


As we only allow top-level polymorphism, the translation from \impeff
to \feff is straightforward. Generalisation (type abstraction) only
occurs on top-level definitions, and instantiation (type application)
only occurs on top-level variable lookup.

%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:V}{x}{\theta(V)}}
%% \semr
%% = \\
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:\forall \many{Z}.V}{x~\theta(\many{Z})}{\theta{V}}} \\
%% \el
%% \]


\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid \forall \many{X}.\effbox{\sigs}\thunk{C} \mid X \\ % \mid \forall X.V \\
\slab{computations} &C      &::=& \rt{V} \mid V \to C  % \mid \forall X.C \\
\\[1ex]
\slab{quantifiers}  &Z      &::=& X \mid \varepsilon \\
\slab{arguments}    &T      &::=& V \mid \sigs
\\[1ex]
\slab{polytypes}    &P      &::=& \forall \many{Z}.Q \\
\slab{monothunks}   &Q      &::=& \effbox{\sigs}\thunk{C}
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{type environments}     &\Gamma &::=& \cdot \mid \Gamma, x:V \\
\end{syntax}

%% Effect extension
%% \begin{equations}
%% \sigs \oplus \emptyset               &=& \emptyset \\
%% \sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
%% \end{equations}

Terms
\begin{syntax}
\slab{values}       &u, v &::=& x \mid k~\many{v} \mid \thunk{d} \\
%%             \mid \Lambda Z.v \mid u~T \\
\slab{computations} &d, e &::=& \key{case}~u~\key{of}~
                                   (k~\many{x_k} \mapsto e_k)_k
                                \mid \force{(u~\many{T})} \\
                    &     &\mid& \lambda x.e \mid d~v 
                           \mid \key{ret}~v \mid \key{let}~x=e~\key{in}~e'
                           \mid c~\many{v} \\
%%   \mid \Lambda Z.e \mid d~T \\
                         &&\mid& \key{handle} ~d~ \key{with}~
                                   (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
                                   x        \mapsto e \\
                         &&\mid& \key{letrec}~\many{f : P = e}~\key{in}~e' \\
\end{syntax}
\caption{\feff Syntax}
\label{fig:feff-syntax}
\end{figure}

\begin{figure*}
$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}
%% \inferrule
%%   {\valg{v}{V} \\
%%    Z \notin \FV(\Gamma)}
%%   {\valg{\Lambda Z.v}{\forall Z.V}}
%% \inferrule
%%   {\valg{u}{\forall Z.V}}
%%   {\valg{u~T}{V[T/Z]}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\forall \many{Z}.\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{(u~\many{T})}}{C[\many{T}/\many{Z}]}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {\compgs{d}{\rt{V}} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\key{let}~x=d~\key{in}~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\compgs{e}{C} \\
%%    Z \notin (\FV(\Gamma) \cup \FV(\sigs))}
%%   {\compgs{\Lambda Z.e}{\forall Z.C}}

%% \inferrule
%%   {\compgs{d}{\forall Z.C}}
%%   {\compgs{d~T}{V[T/Z]}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}

\inferrule
  {(\comp{\Gamma, \many{f : \forall\many{Z}.Q}}{\sigs}{e_i}{Q_i})_i \\
   \comp{\Gamma, \many{f : \forall \many{Z}.Q}}{\sigs}{d}{C}}
  {\compgs{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d}{C}}
\end{mathpar}

\caption{\feff Typing rules}
\label{fig:feff-typing}
\end{figure*}

\section{Small-step semantics}
\label{sec:semantics}

\newcommand{\reducesto}{\longrightarrow}

\begin{figure*}

\begin{equations}
%% (\textrm{Value contexts})\, D
%%   &::=& [~] \mid \key{case}~D~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i \mid \force{D} \mid D~T \\
(\textrm{Delimited computation contexts})\, E
  &::=& [~] \mid E~v \mid \key{let}~x=E~\key{in}~e \\
(\textrm{Computation contexts})\, F
  &::=& [~] \mid F~v \mid \key{let}~x=F~\key{in}~e
            \mid \key{handle}~F~\key{with}~H \\
               %% (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
               %%   x \mapsto e \\
\end{equations}%

\begin{equations}
%% (\Lambda Z.v) T &\reducesto& v[T/Z]
%% \\[1ex]
\key{case}~k_j~\many{v}~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i
  &\reducesto& e_j[\many{v}/\many{x_j}] \\
\force{\thunk{e}} &\reducesto& e
\\[1ex]
(\lambda x.e)~v &\reducesto& e[v/x] \\
%% (\key{rec}~f~x.e)~v &\reducesto& e[\thunk{\key{rec}~f~x.e}/f, v/x] \\
\key{let}~x=\key{ret}~v~\key{in}~e &\reducesto& e[v/x] \\
\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~d
  &\reducesto&
    d[\many{\Lambda{Z}.\thunk{e}}
       [\many{\Lambda{Z}.
                \thunk{\key{letrec}~\many{f : \forall \many{Z}.Q = e}~\key{in}~\force{(f~\many{Z})}}}
       / \many{f}]
     /\many{f}]
\\[1ex]
\key{handle}~(\key{ret}~v)~\key{with}~H
  &\reducesto& H(\key{ret}, v) \\
\key{handle}~E[c~\many{v}]~\key{with}~H
  &\reducesto& H(c, \many{v}, \thunk{\lambda z.E[\key{ret}~z]}) \\
%% \key{handle}~(\key{ret}~v)~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%     \key{let}~x=\key{ret}~v~\key{in}~e \\
%% \key{handle}~E[c_j~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      e_j[\many{v}/\many{x_j}, \thunk{\lambda z.E[\key{ret}~z]} / g] \\
%% \key{handle}~E[c~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      \key{let}~z=c~\many{v}~\key{in}~
%%        \key{handle}~E[\key{ret}~z]~\key{with}~
%%           (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%           x \mapsto e, \quad c \neq c_i \text{ for any }i \\
\end{equations}%
where the action of $H = (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert x
\mapsto e$ is given by:
\begin{equations}%
H(\key{ret}, v) &=& e[v/x] \\
H(\key{c_j}, \many{v}, u) &=& e_j[\many{v}/\many{x}, u/g] \\
H(\key{c}, \many{v}, u)
  &=& \key{let}~z=c~\many{v}~\key{in}~
        \key{handle}~\force{u}~z~\key{with}~H,
           \quad c \neq c_i\text{ for any }i
\end{equations}%

\begin{mathpar}
%% \inferrule
%%   {u \reducesto v}
%%   {D[u] \reducesto D[v]}

\inferrule
  {d \reducesto e}
  {F[d] \reducesto F[e]}
\end{mathpar}

\caption{Small-step operational semantics for \feff}
\label{fig:semantics}
\end{figure*}

\section{Related work}
\label{sec:related}


\section{Conclusion and future work}
\label{sec:conclusion}


%% \begin{abstract}
%% This is the text of the abstract.
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keys
%% keyword1, keyword2

%% \section{Introduction}

%% The text of the paper begins here.

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{frankly}

% The bibliography should be embedded for final submission.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\end{document}

Rubbish
-------


sig ReadLine
  = peek : Char
  | nom  : 0

sig Abort
  = aborting : 0

if Bool then {X} else {X} -> X
if tt then t else f = t!
if ff then t else f = f!

0 >> Y [] Y


map {X -> Y} (List X)   []   List Y

top-level functions:

       V == forall Z*.V
  P -> C == {P -> C}

Anywhere:

    V == [e]V
   [] == [e]



d e == d ! e




  P [Sig] V == P -> [Sig]V


 

Push sigs inside:

  [[ [Sig]{C} ]] = [[C]] Sig

  [[ <V> ]] Sig          = [ [[Sig]] ] [[V]]
  [[ [Sig']V -> C ]] Sig = [ [[Sig']] ] [[V]] -> [[C]] Sig

Pull sigs outside:

  [[ {C} ]] = [ ((C)) ]{ [[ C ]]}

  [[ [Sig]V -> C )) = [ [[Sig]] ]V -> [[C]]
  [[ [Sig]V ]]      = < [[V]] >

  (( [Sig]V -> C )) = ((C))
  (( [Sig]V ))      = [[Sig]]

foo : Int
foo = 3

map : {X [] Y} (List X) [] List Y


map : forall e X Y.{{[e]X -> <Y>}[e] [e](List X) -> [e](List Y)}[e]



map : forall e X Y.{[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[ ]{[ ]X -> [ ]Y} [ ](List X) -> [ ](List Y)}
map :              {   {   X ->    Y}    (List X) ->    (List Y)}
map :                  {   X ->    Y}    (List X) ->    (List Y)


map : forall e X Y.[e]{[e]([e]{[e]X -> <Y>}) [e](List X) -> <List Y>}



map :              [e]{[e]{[e]X -> <Y>} [e](List X) -> <List Y>}
map :                 {   {   X -> <Y>}    (List X) -> <List Y>}
map :                     {   X -> <Y>}    (List X) -> <List Y>
map :                     {   X ->  Y }    (List X) ->  List Y

map : {X -> Y} (List X) -> List Y
map f nil        = nil
map f (x :: xs)  = f x :: map f xs


main [Console] List ()

main forall e.[e, Console] {<List ()>}
main          [e, Console] {<List ()>}
main          [   Console] {<List ()>}
main          [   Console]   List ()
main = map ouch ('h' :: ('e' :: ('l' :: ('l' :: ('o' :: nil)))))
