\documentclass[preprint]{sigplanconf}

% US Letter page size
%\pdfpagewidth=8.5in
%\pdfpageheight=11in


% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{MnSymbol}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\many}{\overline}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}

\newcommand{\seml}{\left\llbracket}
\newcommand{\semr}{\right\rrbracket}

\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}


\newcommand\ba{\begin{array}}
\newcommand\ea{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newcommand{\judgeword}[1]{~\mathbf{#1}~}

%\renewcommand{\sig}{\Sigma}
%\renewcommand{\sigs}{\Sigma s}
\newcommand{\sigentails}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\text{-\!-}}\,}

\newcommand{\sigmodels}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\mathord{=}}\,}


% \newcommand{\sigentails}[1]{\vdash_{#1}}

\newcommand{\val}[3]  {#1 \vdash {#2} : {#3}}
\newcommand{\comp}[4]  {#1 \sigentails{#2} {#3} : {#4}}

\newcommand{\rt}[1]{\langle{#1}\rangle}   % returner type

\newcommand{\valg}{\val{\Gamma}}
\newcommand{\compgs}{\comp{\Gamma}{\sigs}}

\newcommand{\is}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}

\newcommand{\makes}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\has}[4] {#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\can}[4]{#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\does}[4]{#1 \sigentails{#2} {#3} \judgeword{has} {#4}}

\newcommand{\pat}[3]{{#1} \judgeword{matches} {#2} \dashv #3}
\newcommand{\patg}[2]{\pat{#1}{#2}{\Gamma}}


\newcommand{\isgs}{\is{\Gamma}{\sigs}}

\newcommand{\makesgs}{\makes{\Gamma}{\sigs}}
\newcommand{\hasgs}{\has{\Gamma}{\sigs}}
\newcommand{\cangs}{\can{\Gamma}{\sigs}}
\newcommand{\doesgs}{\does{\Gamma}{\sigs}}

\newcommand{\sig}{S}
\newcommand{\sigs}{\Sigma}
\newcommand{\psigs}{\hat{\Sigma}}

\newcommand{\X}{X}  % a type variable

\newcommand{\E}{E}  % the effect variable

\newcommand{\U}{U}
\newcommand{\V}{V}
\newcommand{\Us}{\many{\U}}
\newcommand{\Vs}{\many{\V}}

\newcommand{\C}{C}

\newcommand{\tm}{t}
\newcommand{\tu}{u}
\newcommand{\tms}{\many{\tm}}
\newcommand{\tus}{\many{\tu}}

\newcommand{\p}{p}
\newcommand{\ps}{\many{\p}}

\newcommand{\h}{h}

\newcommand{\op}{\mathit{op}}

\newcommand{\effbox}[1]{[#1]}
\newcommand{\ret}[2]{\effbox{#1}{#2}}
\newcommand{\template}[3]{{#1} \mathbin{\effbox{#2}} {#3}}

\newcommand{\key}[1]{\mathsf{#1}}

\newcommand{\handleSymbol}{\mathbin{?}}
\newcommand{\yieldSymbol}{\mathbin{\prec}}
\newcommand{\continueSymbol}{\mathbin{\triangleleft}}
\newcommand{\handleType}[3]{\effbox{{#1} \yieldSymbol \ret{#2}{#3}}}
\newcommand{\handleTypePoly}[2]{\effbox{{#1} \yieldSymbol #2}}
\newcommand{\handleRet}[1]{\effbox{#1}}
\newcommand{\handleOp}[2]{\effbox{{#1} \continueSymbol {#2}}}
\newcommand{\handle}[2]{{#1} \handleSymbol {#2}}

\newcommand{\handleGen}[2]{\key{handle}~{#1}~\key{with}~{#2}}

\newcommand{\thunk}[1]{\{{#1}\}}
%\newcommand{\athunk}[2]{\thunk{#1}_{#2}}
\newcommand{\athunk}[2]{[#2]\thunk{#1}}

\newcommand{\force}[1]{{#1}!}
\newcommand{\app}{\mathbin{\text{@}}}

\newcommand{\con}{K}
\newcommand{\D}{D}

\newcommand{\args}{\mathit{args}}

\newcommand{\rplus}{\mathbin{\mathord{+}\!\!\!\!\mathord{\shortrightarrow}}}
\newcommand{\lplus}{\mathbin{\mathord{+}\!\!\!\!\!\mathord{\shortleftarrow}}}


\newcommand{\VV}{\mathbb{V}}
\newcommand{\VVs}{\many{\VV}}
\newcommand{\CC}{\mathbb{C}}

\newcommand{\inst}[2]{\mathit{inst}({#1}, {#2})}
\newcommand{\instt}[1]{\inst{\theta}{#1}}

%% \newcommand{\oldinst}[3]{\mathit{inst}({#1},{#2},{#3})}
%% \newcommand{\oldinstts}[1]{\oldinst{\theta}{\sigs}{#1}}

%% \newcommand{\appsig}[2]{{#1}\mathord{\cdot}{#2}}



\begin{document}

%% \conferenceinfo{WXYZ '05}{date, City.} 
%% \copyrightyear{2005} 
%% \copyrightdata{[to be supplied]} 

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Do Be Do Be Do}
%% \subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}
           {The University of Edinburgh}
           {}
\authorinfo{Conor McBride}
           {University of Strathclyde}
           {}
%%         {Email1}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle

%% Structure:

%%   Introduction
%%   Examples
%%     parsing
%%     pipes
%%     ...
%%   Frank syntax and type system (source language)
%%     semantics by elaboration into successively simpler languages
%%   pattern matching compilation
%%     option to expose non-exhaustive/incomplete pattern matching as
%%     concrete effects
%%   CBPV
%%   Explicit polymorphism
%%   Small-step semantics (see handlers in action)
%%
%%   Related work
%%
%%     Plotkin+Power, Plotkin+Pretnar, Hancock, Eff, Brady, Kiselyov
%%     et al, Felleisen, Kammar et al, Filinski, Koka, Ahmen+Plotkin,
%%     Staton, Kleisli arrows of outrageous fortune, data types a la carte
%%
%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules

\section{Introduction}
  
\section{Examples}


\section{The source language (Frank)}

Frank has a number of distinctive features.

Inspired by Levy's call-by-push-value (CBPV) calculus, Frank makes an
explicit distinction between computation and value types. However,
where CBPV also has a clear distinction between value terms and
computation terms, Frank is less rigid. The motivation for this design
is to reduce boilerplate in source programs. Frank combines the
advantages of CBPV, call-by-value (a la ML), and effect typing.

With future extensions for dependent types in mind, Frank adopts a
bidirectional typing discipline. A side-effect is that one cannot
write beta-redexes in Frank. We do not view this as a disadvantage.

Inspired by the observation that applying a function to a value is
equivalent to applying a handler to a pure computation, handlers and
functions are unified in Frank. Handlers are further generalised to
multi-handlers, which handle multiple computations simulataneously.

Frank provides a novel form of effect polymorphism, in which it is
never necessary to mention the names of effect variables.

We explain the semantics of Frank programs through a series of program
transformations.

First, we take a fairly standard approach to compiling away pattern
matching (Core Frank). As we may match simultaneously against multiple
side-effecting computations, we must be careful about
order. Optionally, we can expose non-exhaustive/incomplete pattern
matching as concrete effects.

Second, we make the distinction between values terms and computations
explicit, as in CBPV (implicit-eff).

Finally, we make polymorphism explicit. Our ultimate target is F-eff,
an effect-polymorphic variant of Kammar et al's CBPV-inspired
lambda-eff calculus. The small-step semantics of F-eff is a
straightforward variant of that of lambda-eff.




\begin{figure*}
Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
C    &::= \rt{V} \mid \many{\effbox{\sigs}V} \to C \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{array}
\]

Flat signature extension (the right signature must be closed)
\[
\begin{array}{@{}r@{~}l@{}}
\sigs~\emptyset &= \sigs \\
\sigs~(\sigs', \sig~\many{V}) &= (\sigs~\sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u &::=& x \mid f \mid d                                \\ % makes
v &::=& u \mid k~\many{v}                                 % has
          \mid \thunk{e}
\\[1ex]
d &::=& d~\many{e} \mid \force{u} \mid c~\many{v}      \\ % can
e &::=& v \mid \many{r} \mapsto e \mid e \medvert e       % does
\\[1ex]
p &::=& x \mid k~\many{p}                              \\ % pattern 
r &::=& p \mid \handle{c~\many{p}\,}{g} \mid \thunk{g} \\ % request
\end{array}
\]

Typing rules
\medskip

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Phi \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(V)}}

\inferrule
  {\cangs{d}{\rt{V}}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{s}{V}}
  {\hasgs{V}{s}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{\sigs'}{C}{e}}
  {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\cangs{d}{\many{\effbox{\sigs'}V} \to C} \\
   (\does{\Gamma}{\sigs~\sigs'_i}{\rt{V_i}}{e_i})_i}
  {\can{\Gamma}{\sigs}{d~\many{e}}{C}}

\inferrule
  {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
  {\cangs{\force{u}}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\rt{U}}}
\end{mathpar}

$\boxed{\doesgs{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesgs{\rt{V}}{v}}

\inferrule
  {\sigs' \text{ closed} \\
   (\pat{\effbox{\sigs'_i}V_i}{r_i}{\Delta_i})_i \\
   \does{\Gamma, \many{\Delta}}{\sigs}{C}{e}}
  {\doesgs{\many{\effbox{\sigs'}V} \to C}{\many{r} \mapsto e}}

\inferrule
  {\doesgs{V}{e} \\ \doesgs{V}{e'}}
  {\doesgs{V}{e \medvert e'}}
\end{mathpar}

$\boxed{\pat{V}{p}{\Delta}}$

\begin{mathpar}
\inferrule
  { }
  {\pat{V}{x}{x:V}}

\inferrule
  {k~\many{V} \in D~\many{U} \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{D~\many{U}}{k~\many{p}}{\many{\Delta}}}
\end{mathpar}

$\boxed{\pat{\effbox{\sigs}V}{r}{\Delta}}$

\begin{mathpar}
\inferrule
  {\pat{V}{p}{\Delta}}
  {\pat{\effbox{\sigs}V}{p}{\Delta}}

\inferrule
  {c:U(\many{V}) \in \sigs \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{\effbox{\sigs}V}
       {\handle{c~\many{p}}{g}}
       {\many{\Delta}, g:\effbox{\sigs}\thunk{\effbox{}U \to \rt{V}}}}

\inferrule
  { }
  {\pat{\effbox{\sigs}V}{\thunk{x}}{x:\effbox{\sigs}\thunk{\rt{V}}}}
\end{mathpar}


\caption{Frank}
\end{figure*}





\section{Pattern matching compilation (Core Frank)}

\begin{figure*}
Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
C    &::= \rt{V} \mid V \to C \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{array}
\]

Flat signature extension (the right signature must be closed)
\[
\begin{array}{@{}r@{~}l@{}}
\sigs~\emptyset &= \sigs \\
\sigs~(\sigs', \sig~\many{V}) &= (\sigs~\sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u &::=& x \mid f \mid d                           \\ % makes
v &::=& u \mid k~\many{v}                            % has
          \mid \thunk{e}  \\[1ex]
d &::=& d~v \mid \force{u} \mid c~\many{v} \\        % can
e &::=& v \mid \lambda x.e \\                        % does
  &\mid& \key{case}~u~\key{of}~
           (k~\many{x_k} \mapsto e_k)_k \\
  &\mid& \key{handle} ~d~ \key{with}~
           (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
            x        \mapsto e \\
\end{array}
\]

Typing rules
\medskip

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Phi \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(V)}}

\inferrule
  {\cangs{d}{\rt{V}}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{s}{V}}
  {\hasgs{V}{s}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{\sigs'}{C}{e}}
  {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\cangs{d}{V \to C} \\
   \has{\Gamma}{\sigs}{V}{v}}
  {\cangs{d~v}{C}}

\inferrule
  {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
  {\cangs{\force{u}}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\rt{U}}}
\end{mathpar}

$\boxed{\doesgs{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesgs{\rt{V}}{v}}

\inferrule
  {\does{\Gamma, x:V}{\sigs}{C}{e}}
  {\doesgs{V \to C}{\lambda x.e}}

\inferrule
  {\makesgs{u}{D~\many{U}} \\
   (\does{\Gamma, \many{x_k}:\many{V}}{\sigs}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
  {\doesgs{C}{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}}

\inferrule
  {\sigs' \text{ closed} \\
   \can{\Gamma}{\sigs~\sigs'}{d}{\rt{V}} \\
   (\does{\Gamma, \many{x_c}:\many{V}, g_c:\effbox{\sigs~\sigs'}\thunk{U \to \rt{V}}}
         {\sigs}{C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
   \does{\Gamma, x:V}{\sigs}{C}{e}}
  {\does{\Gamma}{\sigs}
         {C}{\key{handle}~ d ~\key{with}~
               (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
                x \mapsto e}}
\end{mathpar}

\caption{Core Frank}
\end{figure*}



\section{CBPV with Implicit polymorphism}

Call by value embedding of Core Frank into implicit-eff:

\begin{equations}
\sem{x} &=& \key{ret}~x \\
\\
\sem{k~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~\key{ret}~(k~\many{x}) \\
\sem{\thunk{e}} &=& \key{ret}~\thunk{\sem{e}} \\
\\
\sem{c~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~c~\many{x} \\
\sem{d~v} &=& \key{let}~x=\sem{v} ~\key{in}~d~x \\
\sem{\force{u}} &=& \key{let}~x=\sem{u} ~\key{in}~\force{x} \\
\\
\sem{\lambda x.e} &=& \lambda x.\sem{e} \\
\multicolumn{3}{@{}l}{\sem{\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{let}~x=\sem{u} ~\key{in}~
    \key{case}~x~\key{of}~(k~\many{x_k} \mapsto \sem{e_k})_k} \\
\multicolumn{3}{@{}l}{\sem{\key{handle}~d~\key{with}~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert x \mapsto e} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{handle}~\sem{d}~\key{with}~ 
            (\handle{c~\many{x_c}}{g_c} \mapsto \sem{e_c})_c
            \medvert x \mapsto \sem{e}} \\
\end{equations}

\begin{figure*}

Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid \effbox{\sigs}\thunk{C} \mid X \\
C    &::= \rt{V} \mid V \to C \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{array}
\]

Flat signature extension
\[
\begin{array}{@{}r@{~}l@{}}
\sigs~\emptyset &= \emptyset \\
\sigs~(\sigs', \sig~\many{V}) &= (\sigs~\sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u, v &::=& x \mid f \mid k~\many{v} \mid \thunk{d}  \\
d, e &::=& \key{case}~u~\key{of}~
           (k~\many{x_k} \mapsto e_k)_k  \mid \force{u} \\
    &\mid& \lambda x.e \mid d~v
     \mid  \key{ret}~v \mid c~\many{v} \\
    &\mid& \key{handle} ~d~ \key{with}~
             (\handle{c~\many{x}}{g} \mapsto e)_c \medvert
             x        \mapsto e \\
\end{array}
\]

Typing rules
\medskip

$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\val{\Gamma, x:V}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Phi \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\valg{f}{\theta(V)}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{u}}{C}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

\inferrule
  {\comp{\Gamma}{\sigs~\sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs~\sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}
\end{mathpar}

\caption{implicit-eff}
\end{figure*}


\section{Explicit polymorphism (F-eff)}

As we only allow top-level polymorphism, the translation from
implicit-eff to explicit-eff is straightforward. Generalisation (type
abstraction) only occurs on top-level definitions, and instantiation
(type application) only occurs on top-level variable lookup.

%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:V}{x}{\theta(V)}}
%% \semr
%% = \\
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:\forall \many{Z}.V}{x~\theta(\many{Z})}{\theta{V}}} \\
%% \el
%% \]

\begin{figure*}

Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid \effbox{\sigs}\thunk{C} \mid X \mid \forall X.V \\
C    &::= \rt{V} \mid V \to C \\  % \mid \forall X.C \\
\\
Z    &::= X \mid \varepsilon \\
T    &::= V \mid \sigs \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \\
\end{array}
\]

Flat signature extension
\[
\begin{array}{@{}r@{~}l@{}}
\sigs~\emptyset &= \emptyset \\
\sigs~(\sigs', \sig~\many{V}) &= (\sigs~\sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u, v &::=& x \mid k~\many{v} \mid \thunk{d}
             \mid \Lambda Z.v \mid u~T \\
d, e &::=& \key{case}~u~\key{of}~
             (k~\many{x_k} \mapsto e_k)_k
     \mid \force{u} \\
     &\mid& \lambda x.e \mid d~v 
      \mid \key{ret}~v \mid \key{let}~x=d~\key{in}~e
      \mid c~\many{v} \\
%%   \mid \Lambda Z.e \mid d~T \\
     &\mid& \key{handle} ~d~ \key{with}~
               (\handle{c~\many{x}}{g} \mapsto e)_c \medvert
               x        \mapsto e \\
\end{array}
\]

Typing rules
\medskip

$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}

\inferrule
  {\valg{v}{V} \\
   Z \notin \FV(\Gamma)}
  {\valg{\Lambda Z.v}{\forall Z.V}}

\inferrule
  {\valg{u}{\forall Z.V}}
  {\valg{u~T}{V[T/Z]}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{u}}{C}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {\compgs{d}{\rt{V}} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\key{let}~x=d~\key{in}~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\compgs{e}{C} \\
%%    Z \notin (\FV(\Gamma) \cup \FV(\sigs))}
%%   {\compgs{\Lambda Z.e}{\forall Z.C}}

%% \inferrule
%%   {\compgs{d}{\forall Z.C}}
%%   {\compgs{d~T}{V[T/Z]}}

\inferrule
  {\comp{\Gamma}{\sigs~\sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs~\sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}
\end{mathpar}

\caption{F-eff}
\end{figure*}

\section{Small-step semantics}

\newcommand{\reducesto}{\longrightarrow}

\begin{figure*}

\begin{equations}
(\textrm{Value contexts})\, D
  &::=& [~] \mid \key{case}~D~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i \mid \force{D} \mid D~T \\
(\textrm{Delimited computation contexts})\, E
  &::=& [~] \mid E~v \mid \key{let}~x=E~\key{in}~e \\
(\textrm{Computation contexts})\, F
  &::=& [~] \mid F~v \mid \key{let}~x=F~\key{in}~e
            \mid \key{handle}~F~\key{with}~
               (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
                 x \mapsto e \\
\end{equations}

\begin{equations}
(\Lambda Z.v) T &\reducesto& v[T/Z]
\\[1ex]
\key{case}~k_j~\many{v}~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i
  &\reducesto& e_j[\many{v}/\many{x_j}] \\
\force{\thunk{e}} &\reducesto& e
\\[1ex]
(\lambda x.e)~v &\reducesto& e[v/x] \\
\key{let}~x=\key{ret}~v~\key{in}~e &\reducesto& e[v/x]
\\[1ex]
\key{handle}~(\key{ret}~v)~\key{with}~
   (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
   x \mapsto e
  &\reducesto&
    \key{let}~x=\key{ret}~v~\key{in}~e \\
\key{handle}~E[c_j~\many{v}]~\key{with}~
   (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
   x \mapsto e
  &\reducesto&
     e_j[\many{v}/\many{x_j}, \thunk{\lambda z.E[\key{ret}~z]} / g] \\
\key{handle}~E[c~\many{v}]~\key{with}~
   (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
   x \mapsto e
  &\reducesto&
     \key{let}~z=c~\many{v}~\key{in}~
       \key{handle}~E[\key{ret}~z]~\key{with}~
          (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
          x \mapsto e, \quad c \neq c_i \text{ for any }i \\
\end{equations}

\begin{mathpar}
\inferrule
  {u \reducesto v}
  {D[u] \reducesto D[v]}

\inferrule
  {d \reducesto e}
  {F[d] \reducesto F[e]}
\end{mathpar}

\caption{Small-step operational semantics for F-eff}
\end{figure*}

\section{Related work}

\section{Conclusion and future work}

%% %%%%%%%%%%%%%%%%%%%%%% Monomorphic Thunk

%% \begin{figure*}


%% \[
%% \begin{array}{@{}r@{~}l@{}}
%% \Us \to \C &\equiv \U_1 \to \dots \to \U_n \to \C \\
%% \\
%% \U, \V &::= \thunk{\C} \mid \D~\Vs \mid \X \\
%% \C     &::= \ret{\sigs}{\V} \mid \V \to \C \\
%% \\
%% \Gamma &::= \cdot \mid \Gamma, x : \V \\
%% \\
%% \sig  &::= \cdot \mid \op : \C, \sig \\
%% \sigs &::= \cdot \mid \sig~\Vs, \sigs \\
%% \end{array}
%% \]

%% Convenience:
%% \begin{mathpar}
%% \inferrule
%%   {\doesgs{\force{\tu}~\tm}{\C}}
%%   {\doesgs{\tu~\tm}{\C}}

%% \inferrule
%%   {\doesgs{\handle{\force{\h}}{\tm}}{\C}}
%%   {\doesgs{\handle{\h}{\tm}}{\C}}
%% \end{mathpar}


%% $\boxed{\isgs{\tm}{\V}}$
%% \begin{mathpar}
%% \inferrule
%%   {x:\V \in \Gamma}
%%   {\is{\Gamma}{\sigs}{x}{\V}}

%% \inferrule
%%   {\doesgs{\tu}{\ret{\sigs'}{\V}} \\
%%    \sigs' \leq \sigs}
%%   {\isgs{\tu}{\V}}
%% \end{mathpar}

%% $\boxed{\hasgs{\V}{\tm}}$
%% \begin{mathpar}
%% \inferrule
%%    {[\hasgs{\U_i}{\tm_i}]_i \\ \con : \Us \to \D~\Vs}
%%    {\hasgs{\D~\Vs}{\con~\tms}}

%% \inferrule
%%   {\kang{\C}{\tm}}
%%   {\hasgs{\thunk{\C}}{\thunk{\tm}}}

%% \inferrule
%%   {\isgs{\tu}{\U} \\ \U=\V}
%%   {\hasgs{\V}{\tu}}
%% \end{mathpar}

%% $\boxed{\doesgs{\tm}{\C}}$
%% \begin{mathpar}
%% \inferrule
%%   {\op : \C \in \sigs}
%%   {\doesgs{\op}{\C}}

%% \inferrule
%%   {\isgs{\tu}{\thunk{\C}}}
%%   {\doesgs{\force{\tu}}{\C}}

%% \inferrule
%%   {\doesgs{\tu}{\U \to \C} \\
%%    \hasgs{\U}{\tm}}
%%   {\doesgs{\tu ~ \tm}{\C}}

%% \end{mathpar}

%% $\boxed{\kang{\C}{\tm}}$
%% \begin{mathpar}
%% \inferrule
%%   {\hasgs{\V}{\tm}}
%%   {\kang{\ret{\sigs}{\V}}{\tm}}

%% \inferrule
%%   {[\pat{\U_i}{\p_i}{\Gamma_i}]_i \\
%%    \kan{\Gamma, (\Gamma_1 \uplus \cdots \uplus \Gamma_n)}{\C}{\tm}}
%%   {\kang{\Us \to \C}{\ps \to \tm}}

%% %% \inferrule
%% %%   {\pat{\U}{\p}{\Gamma'} \\
%% %%    \kan{\Gamma, \Gamma'}{\C}{\tm}}
%% %%   {\kang{\U \to \C}{\ps \to \tm}}

%% \inferrule
%%   {\kang{\C}{\tm} \\ \kang{\C}{\tu}}
%%   {\kang{\C}{\tm \mid \tu}}
%% \end{mathpar}

%% $\boxed{\patg{\V}{\p}}$
%% \begin{mathpar}
%% \inferrule
%%   { }
%%   {\pat{\V}{x}{x : \V}}

%% \inferrule
%%   {[\pat{\U_i}{\p_i}{\Gamma_i}]_i \\ \con : \Us \to \D~\Vs}
%%   {\pat{\D~\Vs}{\con~\ps}{\Gamma_1 \uplus \cdots \uplus \Gamma_n}}
%% \end{mathpar}
%% \caption{Monomorphic Thunk}
%% \end{figure*}

%% %%%%%%%%%%%%%%%%%%%%%% Polymorphic Thunk

%% %% \begin{figure*}

%% %% \newcommand{\asigs}{\sigma}

%% %% \[
%% %% \begin{array}{@{}r@{~}l@{}}
%% %% \VV &::= \thunk{\CC} \mid \D~\VVs \mid \X \\
%% %% \CC &::= \ret{\asigs}{\VV} \mid \VV \to \CC \\
%% %% \\
%% %% \asigs &::= \cdot \mid \sig~\Vs, \asigs \mid \E \\
%% %% \\
%% %% \Gamma &::= \cdot \mid \Gamma, f : \VV \mid \Gamma, x : \V \\
%% %% \end{array}
%% %% \]

%% %% \[
%% %% \begin{array}{@{}r@{~}l@{\quad}l@{}}
%% %% \oldinstts{\X}          &= \theta(\X) \\
%% %% \oldinstts{\thunk{\CC}} &= \thunk{\oldinstts{\CC}} \\
%% %% \oldinstts{\D~\VVs}     &= \D~\oldinstts{\VVs} \\
%% %% \\
%% %% \oldinstts{\ret{\asigs}{\VV}} &= \ret{\appsig{\asigs}{\sigs}}{\oldinstts{\VV}} \\
%% %% \oldinstts{\VV \to \CC}       &= \oldinstts{\VV} \to \oldinstts{\CC} \\
%% %% \\
%% %% \appsig{\cdot}{\sigs} &= \cdot \\
%% %% \appsig{\E}{\sigs} &= \sigs \\
%% %% \appsig{\sig~\Vs, \asigs}{\sigs} &= \sig~\Vs, (\appsig{\asigs}{\sigs}) \backslash \sig \\
%% %% \end{array}
%% %% \]
%% %% \newcommand{\FV}{\mathit{FV}}

%% %% \begin{mathpar}
%% %% \inferrule
%% %%   {f:\VV \in \Gamma \\ \theta \in \FV(\VV) \to \V}
%% %%   {\is{\Gamma}{\sigs}{f}{\oldinstts{\VV}}}
%% %% \end{mathpar}

%% %% \caption{Polymorphic Thunk}

%% %% \end{figure*}

%% \begin{figure*}

%% \newcommand{\asigs}{\sigma}

%% \[
%% \begin{array}{@{}r@{~}l@{}}
%% \VV &::= \thunk{\CC} \mid \D~\VVs \mid \X \\
%% \CC &::= \ret{\asigs}{\VV} \mid \VV \to \CC \\
%% \\
%% \asigs &::= \cdot \mid \sig~\Vs, \asigs \mid \E \\
%% \\
%% \Gamma &::= \cdot \mid \Gamma, f : \VV \mid \Gamma, x : \V \\
%% \end{array}
%% \]

%% \[
%% \begin{array}{@{}r@{~}l@{\quad}l@{}}
%% \instt{\X}          &= \theta(\X) \\
%% \instt{\thunk{\CC}} &= \thunk{\instt{\CC}} \\
%% \instt{\D~\VVs}     &= \D~\instt{\VVs} \\
%% \\
%% \instt{\ret{\asigs}{\VV}} &= \ret{\instt{\asigs}}{\instt{\VV}} \\
%% \instt{\VV \to \CC}       &= \instt{\VV} \to \instt{\CC} \\
%% \\
%% \instt{\cdot}            &= \cdot \\
%% \instt{\E}               &= \theta(\E) \\
%% \instt{\sig~\Vs, \asigs} &= \sig~\instt{\Vs}, (\instt{\asigs} \backslash \sig) \\
%% \end{array}
%% \]

%% \begin{mathpar}
%% \inferrule
%%   {f:\VV \in \Gamma \\ \theta : \FV(\VV) \to \V \\ \theta(\E) = \Sigma }
%%   {\is{\Gamma}{\sigs}{f}{\instt{\VV}}}
%% \end{mathpar}

%% \caption{Polymorphic Thunk}

%% \end{figure*}


%% %%%%%%%%%%%%%%%%%%%%%% Frank = Thunk + handlers

%% \begin{figure*}


%% \begin{mathpar}
%% \inferrule
%%   {\doesgs{\h}{\handleType{\sigs'}{\sigs''}{\U} \to \C} \\
%%    \has{\Gamma}{\sigs''}{\U}{\tm} \\
%%    \sigs' \leq \sigs'' \leq \sigs \oplus \sigs'
%%   }
%%   {\doesgs{\handle{\h}{\tm}}{\C}}

%% \\

%% \inferrule
%%   {\patg{\V}{\p}}
%%   {\patg{\handleType{\sigs'}{\sigs''}{\V}}{\handleRet{\p}}}

%% \inferrule
%%   {\template{\op\,\Us}{}{\U} \in \sig' \\
%%    [\pat{\U_i}{\p_i}{\Gamma_i}] \\
%%    \pat{\thunk{\U \to \ret{\sigs''}{\V}}}{k}{\Gamma}}
%%   {\pat{\handleType{\sigs'}{\sigs''}{\V}}
%%        {\handleOp{\op~\ps}{k}}
%%        {\Gamma_1 \uplus \dots \uplus \Gamma_n \uplus \Gamma}}

%% \end{mathpar}



%% \caption{Frank = Thunk + handlers}
%% \end{figure*}

%% \begin{abstract}
%% This is the text of the abstract.
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keys
%% keyword1, keyword2

%% \section{Introduction}

%% The text of the paper begins here.

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

% \bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\end{document}
