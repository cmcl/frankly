\documentclass[preprint]{sigplanconf}

% US Letter page size
%\pdfpagewidth=8.5in
%\pdfpageheight=11in


% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{MnSymbol}
\usepackage{xspace}

\newcommand{\lameff}{$\lambda_\mathrm{eff}$\xspace}
\newcommand{\feff}{$F_\textrm{eff}$\xspace}
\newcommand{\impeff}{Implicit \lameff}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\many}{\overline}

\newcommand{\sem}[1]{\llbracket{#1}\rrbracket}

\newcommand{\seml}{\left\llbracket}
\newcommand{\semr}{\right\rrbracket}

\newcommand{\FV}{\mathit{FV}}
\newcommand{\dom}{\mathit{dom}}


\newcommand\ba{\begin{array}}
\newcommand\ea{\end{array}}

\newcommand{\bl}{\ba{@{}c@{}}}
\newcommand{\el}{\ea}

\newcommand{\bstack}{\begin{array}[t]{@{}l@{}}}
\newcommand{\estack}{\end{array}}

\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]}
\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}

\newenvironment{syntax}{\[\ba{@{}l@{~}r@{~}c@{~}l@{}}}{\ea\]}


\newcommand{\judgeword}[1]{~\mathbf{#1}~}

%\renewcommand{\sig}{\Sigma}
%\renewcommand{\sigs}{\Sigma s}
\newcommand{\sigentails}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\text{-\!-}}\,}

\newcommand{\sigmodels}[1]{\mathbin{[{\text{\scriptsize ${#1}$}}]\!\mathord{=}}\,}


% \newcommand{\sigentails}[1]{\vdash_{#1}}

\newcommand{\val}[3]  {#1 \vdash {#2} : {#3}}
\newcommand{\comp}[4]  {#1 \sigentails{#2} {#3} : {#4}}

\newcommand{\rt}[1]{\langle{#1}\rangle}   % returner type

\newcommand{\valg}{\val{\Gamma}}
\newcommand{\compgs}{\comp{\Gamma}{\sigs}}

\newcommand{\is}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}

\newcommand{\makes}[4]  {#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\has}[4] {#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\can}[4]{#1 \sigentails{#2} {#3} \judgeword{is} {#4}}
\newcommand{\does}[4]{#1 \sigentails{#2} {#3} \judgeword{has} {#4}}
\newcommand{\idoes}[3]{#1 \vdash {#2} \judgeword{has} {#3}}

\newcommand{\effs}[2]{{#1} \judgeword{does} {#2}}

\newcommand{\pat}[3]{{#1} \judgeword{matches} {#2} \dashv #3}
\newcommand{\patg}[2]{\pat{#1}{#2}{\Gamma}}


\newcommand{\isgs}{\is{\Gamma}{\sigs}}

\newcommand{\makesgs}{\makes{\Gamma}{\sigs}}
\newcommand{\hasgs}{\has{\Gamma}{\sigs}}
\newcommand{\cangs}{\can{\Gamma}{\sigs}}
\newcommand{\doesgs}{\does{\Gamma}{\sigs}}
\newcommand{\idoesg}{\idoes{\Gamma}}

\newcommand{\sig}{S}
\newcommand{\sigs}{\Sigma}

%% \newcommand{\sig}{\Sigma}
%% \newcommand{\sigs}{E}


\newcommand{\X}{X}  % a type variable

\newcommand{\E}{E}  % the effect variable

\newcommand{\U}{U}
\newcommand{\V}{V}
\newcommand{\Us}{\many{\U}}
\newcommand{\Vs}{\many{\V}}

\newcommand{\C}{C}

\newcommand{\tm}{t}
\newcommand{\tu}{u}
\newcommand{\tms}{\many{\tm}}
\newcommand{\tus}{\many{\tu}}

\newcommand{\p}{p}
\newcommand{\ps}{\many{\p}}

\newcommand{\h}{h}

\newcommand{\op}{\mathit{op}}

\newcommand{\effbox}[1]{[#1]}
\newcommand{\ret}[2]{\effbox{#1}{#2}}
\newcommand{\template}[3]{{#1} \mathbin{\effbox{#2}} {#3}}

\newcommand{\key}[1]{\mathsf{#1}}

\newcommand{\handleSymbol}{\mathbin{?}}
\newcommand{\yieldSymbol}{\mathbin{\prec}}
\newcommand{\continueSymbol}{\mathbin{\triangleleft}}
\newcommand{\handleType}[3]{\effbox{{#1} \yieldSymbol \ret{#2}{#3}}}
\newcommand{\handleTypePoly}[2]{\effbox{{#1} \yieldSymbol #2}}
\newcommand{\handleRet}[1]{\effbox{#1}}
\newcommand{\handleOp}[2]{\effbox{{#1} \continueSymbol {#2}}}
\newcommand{\handle}[2]{{#1} \handleSymbol {#2}}

\newcommand{\handleGen}[2]{\key{handle}~{#1}~\key{with}~{#2}}

\newcommand{\thunk}[1]{\{{#1}\}}
%\newcommand{\athunk}[2]{\thunk{#1}_{#2}}
\newcommand{\athunk}[2]{[#2]\thunk{#1}}

\newcommand{\force}[1]{{#1}!}
\newcommand{\app}{\mathbin{\text{@}}}

\newcommand{\con}{K}
\newcommand{\D}{D}

\newcommand{\args}{\mathit{args}}

\newcommand{\rplus}{\mathbin{\mathord{+}\!\!\!\!\mathord{\shortrightarrow}}}
\newcommand{\lplus}{\mathbin{\mathord{+}\!\!\!\!\!\mathord{\shortleftarrow}}}


\newcommand{\VV}{\mathbb{V}}
\newcommand{\VVs}{\many{\VV}}
\newcommand{\CC}{\mathbb{C}}

\newcommand{\inst}[2]{\mathit{inst}({#1}, {#2})}
\newcommand{\instt}[1]{\inst{\theta}{#1}}

%% \newcommand{\oldinst}[3]{\mathit{inst}({#1},{#2},{#3})}
%% \newcommand{\oldinstts}[1]{\oldinst{\theta}{\sigs}{#1}}

%% \newcommand{\appsig}[2]{{#1}\mathord{\cdot}{#2}}


\newcommand\slab[1]{(\textrm{#1})}


\begin{document}

%% \conferenceinfo{WXYZ '05}{date, City.} 
%% \copyrightyear{2005} 
%% \copyrightdata{[to be supplied]} 

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Do Be Do Be Do}
%% \subtitle{Subtitle Text, if any}

\authorinfo{Sam Lindley}
           {The University of Edinburgh}
           {}
\authorinfo{Conor McBride}
           {University of Strathclyde}
           {}
%%         {Email1}
%% \authorinfo{Name2\and Name3}
%%            {Affiliation2/3}
%%            {Email2/3}

\maketitle

%% Structure:

%%   Introduction
%%   Examples
%%     parsing
%%     pipes
%%     ...
%%   Frank syntax and type system (source language)
%%     semantics by elaboration into successively simpler languages
%%   pattern matching compilation
%%     option to expose incomplete/ambiguous pattern matching as
%%     concrete effects
%%   CBPV
%%   Explicit polymorphism
%%   Small-step semantics (see handlers in action)
%%
%%   Related work
%%
%%     Plotkin+Power, Plotkin+Pretnar, Hancock, Eff, Brady, Kiselyov
%%     et al, Felleisen, Kammar et al, Filinski, Koka, Ahmen+Plotkin,
%%     Staton, Kleisli arrows of outrageous fortune, data types a la carte
%%
%%   Future work
%%     Efficient implementation
%%     Dependent types/session types/indexing
%%     Seemless syntactic support for the data type view of
%%     computations
%%     Handlers for arrows and idioms
%%     Relationship with type classes/modules

\section{Introduction}

This paper explores the design of Frank, a strict functional
programming language designed from the ground up around a novel
variant of Plotkin and Pretnar's \emph{effect
  handler}~\cite{PlotkinP09, PlotkinP13} abstraction.

In Frank, effect handlers strictly generalise functions. In the
general case an effect handler acts as an interpreter for a finite set
of commands whose signatures are statically tracked by the type
system. A function is the special case of an effect handler that
interprets the empty set of commands.

The main contributions of this paper are:
\begin{itemize}
\item Frank, a functional programming language featuring a
  bidirectional effect type system, effect polymorphism, and effect
  handlers.
\item A novel approach to effect polymorphism which avoids all mention
  of effect variables, crucially relying on the observation that one
  must always instantiate the effects of a function being applied with
  the current \emph{ambient} effects.
\item The combination of pattern matching and effect handlers in such
  a way that incomplete or ambiguous pattern matching can be realised
  as concrete effects that can be handled however the programmer
  chooses using further effect handlers.
\item A characterisation of effect-handlers as generalised functions.
\item Multi-handlers for handling multiple computations over different
  effect sets synchronously.
\item A type system for Frank.
\item A series of type preserving translations from Frank into
  successively more canonical type systems, culminating in \feff a
  polymorphic variant of the lambda-eff calculus of Kammar et al,
  which in turn is an extension of Levy's call-by-push-value calculus.
\item A straightforward small-step operational semantics for \feff,
  yielding, in combination with the translations to \feff, a type
  soundness result for Frank.
\end{itemize}

A number of other languages and libraries are built around effect
handlers and algebraic effects.

Bauer and Pretnar's Eff~\cite{BauerP12}. A significant difference
between Frank and the original version of Eff~\cite{BauerP12} is that
the latter provides no support for effect typing. Recently Bauer and
Pretnar have designed an effect type system for
Eff~\cite{BauerP13}. Their implementation~\cite{Pretnar13} supports
Hindley-Milner type inference, and the type system incorporates effect
sub-typing. In contrast, Frank uses bidirectional type inference, and
avoids sub-typing altogether.

Handlers in action~\cite{KammarLO13}. In previous work with Kammar and
Oury~\cite{KammarLO13}, the first author designed and experimented
with a number of effect handler libraries for languages ranging from
Racket, to SML, to Haskell. Apart from the Haskell library, our other
libraries have no effect typing support. The Haskell library takes
advantage of type classes to simulate an effect type system not
entirely dissimilar to that of Frank. As Haskell is lazy, the Haskell
library cannot be used to write direct-style effectful programs - one
must instead adopt a monadic style. Furthermore, although there are a
number of ways of almost simulating effect type systems in Haskell,
none is without its flaws. Kiselyov et al~\cite{KiselyovSS13} have
designed a similar Haskell library for effect handlers, making
slightly different design choices.

Brady~\cite{Brady13} has designed a library and DSL for programming
with effects in his dependently typed Idris language. Like the Haskell
libraries, Brady's library currently requires the programmer to write
effectful code in a monadic style.

The first author has been plotting Frank since
2007~\cite{McBride07}. He has implemented a prototype of a previous
version of Frank~\cite{McBride12}. The design described in the current
paper has much in common with that implementation, but there are some
syntactic and semantic differences. The most important change in the
current design is the introduction of multi-handlers as a
generalisation of both functions and handlers.

The rest of the paper is structured as follows.
%
Section~\ref{sec:examples} introduces Frank by
example. Section~\ref{sec:frank} presents a type system for
Frank. Sections~\ref{sec:core}, \ref{sec:impeff} and \ref{sec:feff}
describes a series of program translations targetting successively
more explicit type systems, culminating in \feff, a variant of Kammar
et al's \lameff calculus. Section~\ref{sec:semantics} gives a
semantics for \feff, which when composed with all of the program
translations, yields a semantics for Frank. Section~\ref{sec:related}
outlines related work and Section~\ref{sec:conclusion} concludes.


\section{Examples}
\label{sec:examples}

\subsection{Pipes}

\subsection{Modular rollback}

\subsection{Effect polymorphism with an invisible effect variable}


\section{The source language (Frank)}
\label{sec:frank}

Frank has a number of distinctive features.

Inspired by Levy's call-by-push-value (CBPV) calculus, Frank makes an
explicit distinction between computation and value types. However,
where CBPV also has a clear distinction between value terms and
computation terms, Frank is less rigid. The motivation for this design
is to reduce boilerplate in source programs. Frank combines the
advantages of CBPV, call-by-value (a la ML), and effect typing.

With future extensions for dependent types in mind, Frank adopts a
bidirectional typing discipline. A side-effect is that one cannot
write beta-redexes in Frank. We do not view this as a disadvantage.

Inspired by the observation that applying a function to a value is
equivalent to applying a handler to a pure computation, handlers and
functions are unified in Frank. Handlers are further generalised to
multi-handlers, which handle multiple computations simulataneously.

Frank provides a novel form of effect polymorphism, in which it is
never necessary to mention the names of effect variables.

We explain the semantics of Frank programs through a series of program
transformations.

First, we take a fairly standard approach to compiling away pattern
matching (Core Frank). As we may match simultaneously against multiple
side-effecting computations, we must be careful about
order. Optionally, we can expose non-exhaustive/incomplete pattern
matching as concrete effects.

Second, we make the distinction between values terms and computations
explicit, as in CBPV (\impeff).

Finally, we make polymorphism explicit. Our ultimate target is \feff,
an effect-polymorphic variant of Kammar et al's CBPV-inspired
lambda-eff calculus. The small-step semantics of \feff is a
straightforward variant of that of lambda-eff.


\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V   &::=& D~\many{U} \mid \thunk{C} \mid X \\
\slab{computations} &C      &::=& R \mid R \to C \\
\slab{returners}    &R      &::=& \effbox{\sigs}V
\\[1ex]
\slab{signatures}   &\sig   &::=& \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs  &::=&
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{contexts}     &\Gamma &::=& \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{syntax}

Effect extension
\begin{equations}
\sigs \oplus \emptyset               &=& \sigs \\
\sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
\end{equations}

Terms
\begin{syntax}
\slab{inferred values}&u       &::=& x \mid f \mid d                                \\
\slab{checked values}&v        &::=& u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferred computations}&d &::=& \force{u} \mid d~e \mid c~\many{v}
                               \mid  \key{let}~x=d~\key{in}~d' \\
                             &&\mid& \key{letrec}~\many{f : \forall \varepsilon \many{X}.V = e}~\key{in}~d \\
\slab{checked computations}&e  &::=& v \mid \many{r} \mapsto e \mid e \medvert e
\\[1ex]
\slab{value patterns}&p       &::=& x \mid k~\many{p}                              \\
\slab{computation patterns}&r &::=& p \mid \handle{c~\many{p}\,}{g} \mid \thunk{g} \\
\end{syntax}

\caption{Frank Syntax}
\end{figure}

\begin{figure*}
$\boxed{\effs{C}{\sigs}}$

\begin{mathpar}
\inferrule
  { }
  {\effs{\effbox{\sigs}V}{\sigs}}

\inferrule
  {\effs{C}{\sigs}}
  {\effs{R \to C}{\sigs}}
\end{mathpar}

$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Gamma \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(V)}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{s}{V}}
  {\hasgs{V}{s}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\idoes{\Gamma}{C}{e}}
  {\hasgs{\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\thunk{C}} \\ \effs{C}{\sigs}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{\effbox{\sigs'}V \to C} \\
   \idoesg{\effbox{\sigs \oplus \sigs'}V}{e}}
  {\can{\Gamma}{\sigs}{d~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\effbox{\sigs}U}}

\inferrule
  {\cangs{d}{\rt{V}} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \varepsilon \many{X}.V}}{e_i}{V_i})_i \\
   \can{\Gamma, \many{f : \forall \varepsilon \many{X}.V}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.V = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\idoesg{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\idoesg{\effbox{\sigs}V}{v}}

\inferrule
  {\many{\sigs'} \text{ closed} \\
   (\pat{\effbox{\sigs'_i}V_i}{r_i}{\Delta_i})_i \\
   \idoes{\Gamma, \many{\Delta}}{C}{e}}
  {\idoesg{\many{\effbox{\sigs'}V} \to C}{\many{r} \mapsto e}}

\inferrule
  {\idoesg{C}{e} \\ \idoesg{C}{e'}}
  {\idoesg{C}{e \medvert e'}}
\end{mathpar}

$\boxed{\pat{V}{p}{\Delta}}$

\begin{mathpar}
\inferrule
  { }
  {\pat{V}{x}{x:V}}

\inferrule
  {k~\many{V} \in D~\many{U} \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{D~\many{U}}{k~\many{p}}{\many{\Delta}}}
\end{mathpar}

$\boxed{\pat{R}{r}{\Delta}}$

\begin{mathpar}
\inferrule
  {\pat{V}{p}{\Delta}}
  {\pat{\effbox{\sigs}V}{p}{\Delta}}

\inferrule
  {c:U(\many{V}) \in \sigs \\
   (\pat{V_i}{p_i}{\Delta_i})_i}
  {\pat{\effbox{\sigs}V}
       {\handle{c~\many{p}}{g}}
       {\many{\Delta}, g:\thunk{\effbox{\emptyset}U \to \effbox{\sigs}V}}}

\inferrule
  { }
  {\pat{\effbox{\sigs}V}{\force{x}}{x:\thunk{\effbox{\sigs}V}}}
\end{mathpar}

\caption{Frank Typing Rules}
\end{figure*}


\section{Pattern matching compilation (Core Frank)}
\label{sec:core}


Core Frank replaces multi-handlers with a combination of standard
call-by-value functions, case statements, and unary effect handlers.

A superficial change to the types is that rather than annotating value
returning computations with effects, we shift such labels to the thunk
containing the computation. The former design seems more convenient to
program with, which is why we adopt it in the source language. The
latter design leads to a slightly more uniform presentation of the
type rules (the checking judgement for computations now has the same
shape as the checking judgement for values, and we no longer need the
$\judgeword{does}$ judgement).

Multi-handlers in Frank become curried function over suspended
computations.

Shallow pattern matching on a single request becomes unary effect
handling. Shallow pattern matching on a data type value becomes case
analysis. Nested pattern matching on multiple computations is realised
as a pattern matching tree constructed from handlers and case
statements. Standard algorithms for pattern matching compilation
apply. 

It may be instructive to observe the representation of the core
language handler and case constructs in the source language.

\[
\ba{@{}l@{}}
\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k
  \equiv
    \key{let}~h = \thunk{\!\!\mathord{\medvert}_{\!\!k} (k~\many{x_k} \mapsto e_k)}~\key{in}~h~u \\
\key{handle} ~d~ \key{with}~
           (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
            x        \mapsto e
  \equiv \\
\qquad
     \key{let}~h = \thunk{\!\!\medvert_{\!\!c} (\handle{c~\many{x_c}}{g_c} \mapsto e_c) \medvert x \mapsto e}
     ~\key{in}~h~d
\ea
\]



\begin{figure}
Types
\begin{syntax}
\slab{values}       &U, V &::= D~\many{U} \mid  \effbox{\sigs}\thunk{C} \mid X \\
\slab{computations} &C    &::= \rt{V} \mid V \to C
\\[1ex]
\slab{signatures}   &\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\slab{effects}      &\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon
\\[1ex]
\slab{contexts}     &\Gamma &::= \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{syntax}

Effect extension
\begin{equations}
\sigs \oplus \emptyset               &=& \sigs \\
\sigs \oplus (\sigs', \sig~\many{V}) &=& (\sigs \oplus \sigs'), \sig~\many{V} \\
\end{equations}

Terms
\begin{syntax}
\slab{inferred values}       &u  &::= & x \mid f \mid d                           \\
\slab{checked values}        &v  &::= & u \mid k~\many{v} \mid \thunk{e}
\\[1ex]
\slab{inferred computations} &d  &::= & \force{u} \mid d~v \mid c~\many{v}
                                  \mid  \key{let}~x=d~\key{in}~d' \\
                             &   &\mid& \key{letrec}~\many{f : \forall \varepsilon \many{X}.V = e}~\key{in}~d \\
\slab{checked computations}  &e  &::= & v \mid \lambda x.e \\
  &&\mid& \key{case}~u~\key{of}~
            (k~\many{x_k} \mapsto e_k)_k \\
  &&\mid& \key{handle} ~d~ \key{with}
            \bstack
            ~~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \\
            \medvert~ x        \mapsto e \\
            \estack \\
\end{syntax}
\caption{Core Frank Syntax}
\end{figure}

\begin{figure*}
$\boxed{\makes{\Gamma}{\sigs}{u}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\makesgs{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\makes{\Gamma, x:V}{\sigs}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Phi \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\makesgs{f}{\theta(V)}}

\inferrule
  {\cangs{d}{\rt{V}}}
  {\makesgs{d}{V}}
\end{mathpar}

$\boxed{\has{\Gamma}{\sigs}{V}{v}}$

\begin{mathpar}
\inferrule
  {\makesgs{s}{V}}
  {\hasgs{V}{s}}

\inferrule
  {(\hasgs{V_i}{v_i})_i \\
   k~\many{V} \in D~\many{U}}
  {\hasgs{D~\many{U}}{k~\many{v}}}

\inferrule
  {\does{\Gamma}{\sigs'}{C}{e}}
  {\hasgs{\effbox{\sigs'}\thunk{C}}{\thunk{e}}}
\end{mathpar}

$\boxed{\can{\Gamma}{\sigs}{d}{C}}$

\begin{mathpar}
\inferrule
  {\makesgs{u}{\effbox{\sigs}\thunk{C}}}
  {\cangs{\force{u}}{C}}

\inferrule
  {\cangs{d}{V \to C} \\
   \has{\Gamma}{\sigs}{V}{v}}
  {\cangs{d~v}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   (\hasgs{V_i}{v_i})_i}
  {\cangs{c~\many{v}}{\rt{U}}}

\inferrule
  {\cangs{d}{\effbox{\sigs}V} \\
   \can{\Gamma, x:V}{\sigs}{d'}{C}}
  {\cangs{\key{let}~x=d~\key{in}~d'}{C}}

\inferrule
  {(\idoes{\Gamma, \many{f : \forall \varepsilon \many{X}.V}}{e_i}{V_i})_i \\
   \can{\Gamma, \many{f : \forall \varepsilon \many{X}.V}}{\sigs}{d}{C}}
  {\cangs{\key{letrec}~\many{f : \forall \varepsilon \many{X}.V = e}~\key{in}~d}{C}}
\end{mathpar}

$\boxed{\doesgs{C}{e}}$

\begin{mathpar}
\inferrule
  {\hasgs{V}{v}}
  {\doesgs{\rt{V}}{v}}

\inferrule
  {\does{\Gamma, x:V}{\sigs}{C}{e}}
  {\doesgs{V \to C}{\lambda x.e}}

\inferrule
  {\makesgs{u}{D~\many{U}} \\
   (\does{\Gamma, \many{x_k}:\many{V}}{\sigs}{C}{e_k})_{k~\many{V} \in D~\many{U}}}
  {\doesgs{C}{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}}

\inferrule
  {\sigs' \text{ closed} \\
   \can{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\does{\Gamma, \many{x_c}:\many{V}, g_c:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
         {\sigs}{C}{e_c})_{c : U(\many{V}) \in \sigs'} \\
   \does{\Gamma, x:V}{\sigs}{C}{e}}
  {\does{\Gamma}{\sigs}
         {C}{\key{handle}~ d ~\key{with}~
               (\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert
                x \mapsto e}}
\end{mathpar}

\caption{Core Frank Typing Rules}
\end{figure*}



\section{\lameff with implicit polymorphism}
\label{sec:impeff}

Call by value embedding of Core Frank into \impeff:

\begin{equations}
\sem{x} &=& \key{ret}~x \\
\\
\sem{k~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~\key{ret}~(k~\many{x}) \\
\sem{\thunk{e}} &=& \key{ret}~\thunk{\sem{e}} \\
\\
\sem{c~\many{v}} &=& \key{let}~\many{x}=\sem{\many{v}} ~\key{in}~c~\many{x} \\
\sem{d~v} &=& \key{let}~x=\sem{v} ~\key{in}~d~x \\
\sem{\force{u}} &=& \key{let}~x=\sem{u} ~\key{in}~\force{x} \\
\\
\sem{\lambda x.e} &=& \lambda x.\sem{e} \\
\multicolumn{3}{@{}l}{\sem{\key{case}~u~\key{of}~(k~\many{x_k} \mapsto e_k)_k} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{let}~x=\sem{u} ~\key{in}~
    \key{case}~x~\key{of}~(k~\many{x_k} \mapsto \sem{e_k})_k} \\
\multicolumn{3}{@{}l}{\sem{\key{handle}~d~\key{with}~(\handle{c~\many{x_c}}{g_c} \mapsto e_c)_c \medvert x \mapsto e} =} \\
\multicolumn{3}{@{}l}
  {\qquad \key{handle}~\sem{d}~\key{with}~ 
            (\handle{c~\many{x_c}}{g_c} \mapsto \sem{e_c})_c
            \medvert x \mapsto \sem{e}} \\
\end{equations}

\begin{figure*}

Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid \effbox{\sigs}\thunk{C} \mid X \\
C    &::= \rt{V} \mid V \to C \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \mid f:\forall \varepsilon \many{X}.V \\
\end{array}
\]

Flat signature extension
\[
\begin{array}{@{}r@{~}l@{}}
\sigs \oplus \emptyset &= \emptyset \\
\sigs \oplus (\sigs', \sig~\many{V}) &= (\sigs \oplus \sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u, v &::=& x \mid f \mid k~\many{v} \mid \thunk{d}  \\
d, e &::=& \key{case}~u~\key{of}~
           (k~\many{x_k} \mapsto e_k)_k  \mid \force{u} \\
    &\mid& \lambda x.e \mid d~v
     \mid  \key{ret}~v \mid c~\many{v} \\
    &\mid& \key{handle} ~d~ \key{with}~
             (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
             x        \mapsto e \\
\end{array}
\]

Typing rules
\medskip

$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

%% \inferrule
%%   {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%    \theta(\varepsilon) = \sigs}
%%   {\val{\Gamma, x:V}{x}{\theta(V)}}

\inferrule
  {f:\forall \varepsilon \many{X}.V \in \Phi \\
   \dom(\theta) = \set{\varepsilon, \many{X}} \\
   \theta(\varepsilon) = \sigs}
  {\valg{f}{\theta(V)}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{u}}{C}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}
\end{mathpar}

\caption{\impeff}
\end{figure*}


\section{Explicit polymorphism (\feff)}
\label{sec:feff}


As we only allow top-level polymorphism, the translation from \impeff
to \feff is straightforward. Generalisation (type abstraction) only
occurs on top-level definitions, and instantiation (type application)
only occurs on top-level variable lookup.

%% \[
%% \bl
%% \seml
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:V}{x}{\theta(V)}}
%% \semr
%% = \\
%%   \inferrule
%%     {\dom(\theta) = \set{\varepsilon} \cup \FV(V) \backslash (\FV(\Gamma) \cup \FV(\sigs)) \\
%%      \theta(\varepsilon) = \sigs}
%%     {\val{\Gamma, x:\forall \many{Z}.V}{x~\theta(\many{Z})}{\theta{V}}} \\
%% \el
%% \]

\begin{figure*}

Types, signatures, type environments

\[
\begin{array}{@{}r@{~}l@{}}
U, V &::= D~\many{U} \mid \effbox{\sigs}\thunk{C} \mid X \mid \forall X.V \\
C    &::= \rt{V} \mid V \to C \\  % \mid \forall X.C \\
\\
Z    &::= X \mid \varepsilon \\
T    &::= V \mid \sigs \\
\\
\sig  &::= \cdot \mid c : U(\many{V}), \sig \\
\sigs &::=
  \emptyset \mid \sigs, \sig~\many{V} \mid \varepsilon \\
\\
\Gamma &::= \cdot \mid \Gamma, x:V \\
\end{array}
\]

Flat signature extension
\[
\begin{array}{@{}r@{~}l@{}}
\sigs \oplus \emptyset &= \emptyset \\
\sigs \oplus (\sigs', \sig~\many{V}) &= (\sigs \oplus \sigs'), \sig~\many{V} \\
\end{array}
\]

Syntax

\[
\begin{array}{@{}r@{~}c@{~}l@{}}
u, v &::=& x \mid k~\many{v} \mid \thunk{d}
             \mid \Lambda Z.v \mid u~T \\
d, e &::=& \key{case}~u~\key{of}~
             (k~\many{x_k} \mapsto e_k)_k
     \mid \force{u} \\
     &\mid& \lambda x.e \mid d~v 
      \mid \key{ret}~v \mid \key{let}~x=d~\key{in}~e
      \mid c~\many{v} \\
%%   \mid \Lambda Z.e \mid d~T \\
     &\mid& \key{handle} ~d~ \key{with}~
               (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
               x        \mapsto e \\
     &\mid& \key{rec}~f~x.e \\
\end{array}
\]

Typing rules
\medskip

$\boxed{\valg{v}{V}}$
\begin{mathpar}
\inferrule
  {x:V \in \Gamma}
  {\valg{x}{V}}

\inferrule
  {\valg{V_i}{v_i} \\
   k~\many{V} \in D~\many{U}}
  {\valg{D~\many{U}}{k~\many{v}}}

\inferrule
  {\compgs{e}{C}}
  {\valg{\thunk{e}}{\effbox{\sigs}\thunk{C}}}

\inferrule
  {\valg{v}{V} \\
   Z \notin \FV(\Gamma)}
  {\valg{\Lambda Z.v}{\forall Z.V}}

\inferrule
  {\valg{u}{\forall Z.V}}
  {\valg{u~T}{V[T/Z]}}
\end{mathpar}

$\boxed{\compgs{e}{C}}$
\begin{mathpar}
\inferrule
  {\valg{u}{D~\many{U}} \\
   (\comp{\Gamma, \many{x_k}:\many{V}}{\sigs}{e_k}{C})_{k~\many{V} \in D~\many{U}}}
  {\compgs{\key{case}~ u ~\key{of}~
               (k~\many{x_k} \mapsto e_k)_k}
          {C}}

\inferrule
  {\valg{u}{\effbox{\sigs}\thunk{C}}}
  {\compgs{\force{u}}{C}}

\inferrule
  {\comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\lambda x.e}{V \to C}}

\inferrule
  {\compgs{d}{V \to C} \\
   \valg{v}{V}}
  {\compgs{d~v}{C}}

\inferrule
  {\valg{v}{V}}
  {\compgs{\key{ret}~v}{\rt{V}}}

\inferrule
  {\compgs{d}{\rt{V}} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs{\key{let}~x=d~\key{in}~e}{C}}

\inferrule
  {c : U(\many{V}) \in \sigs \\
   \valg{v_i}{V_i}}
  {\compgs{c~\many{v}}{\rt{U}}}

%% \inferrule
%%   {\compgs{e}{C} \\
%%    Z \notin (\FV(\Gamma) \cup \FV(\sigs))}
%%   {\compgs{\Lambda Z.e}{\forall Z.C}}

%% \inferrule
%%   {\compgs{d}{\forall Z.C}}
%%   {\compgs{d~T}{V[T/Z]}}

\inferrule
  {\comp{\Gamma}{\sigs \oplus \sigs'}{d}{\rt{V}} \\
   (\comp{\Gamma, \many{x_c}:\many{V},
                  g:\effbox{\sigs \oplus \sigs'}\thunk{U \to \rt{V}}}
       {\sigs}{e_c}{C})_{c : U(\many{V}) \in \sigs'} \\
   \comp{\Gamma, x:V}{\sigs}{e}{C}}
  {\compgs
     {\key{handle}~ d ~\key{with}~
           (\handle{c~\many{x_c}}{g} \mapsto e_c)_c \medvert
           x \mapsto e}
     {C}}

\inferrule
  {\comp{\Gamma, f:\effbox{\sigs}\thunk{V \to C}, x:V}{\sigs}{e}{C}}
  {\compgs{\key{rec}~f~x.e}{V \to C}}
\end{mathpar}

\caption{\feff}
\end{figure*}

\section{Small-step semantics}
\label{sec:semantics}

\newcommand{\reducesto}{\longrightarrow}

\begin{figure*}

\begin{equations}
(\textrm{Value contexts})\, D
  &::=& [~] \mid \key{case}~D~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i \mid \force{D} \mid D~T \\
(\textrm{Delimited computation contexts})\, E
  &::=& [~] \mid E~v \mid \key{let}~x=E~\key{in}~e \\
(\textrm{Computation contexts})\, F
  &::=& [~] \mid F~v \mid \key{let}~x=F~\key{in}~e
            \mid \key{handle}~F~\key{with}~H \\
               %% (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
               %%   x \mapsto e \\
\end{equations}%

\begin{equations}
(\Lambda Z.v) T &\reducesto& v[T/Z]
\\[1ex]
\key{case}~k_j~\many{v}~\key{of}~(k_i~\many{x_i} \mapsto e_i)_i
  &\reducesto& e_j[\many{v}/\many{x_j}] \\
\force{\thunk{e}} &\reducesto& e
\\[1ex]
(\lambda x.e)~v &\reducesto& e[v/x] \\
(\key{rec}~f~x.e)~v &\reducesto& e[\thunk{\key{rec}~f~x.e}/f, v/x] \\
\key{let}~x=\key{ret}~v~\key{in}~e &\reducesto& e[v/x]
\\[1ex]
\key{handle}~(\key{ret}~v)~\key{with}~H
  &\reducesto& H(\key{ret}, v) \\
\key{handle}~E[c~\many{v}]~\key{with}~H
  &\reducesto& H(c, \many{v}, \thunk{\lambda z.E[\key{ret}~z]}) \\
%% \key{handle}~(\key{ret}~v)~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%     \key{let}~x=\key{ret}~v~\key{in}~e \\
%% \key{handle}~E[c_j~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      e_j[\many{v}/\many{x_j}, \thunk{\lambda z.E[\key{ret}~z]} / g] \\
%% \key{handle}~E[c~\many{v}]~\key{with}~
%%    (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%    x \mapsto e
%%   &\reducesto&
%%      \key{let}~z=c~\many{v}~\key{in}~
%%        \key{handle}~E[\key{ret}~z]~\key{with}~
%%           (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert
%%           x \mapsto e, \quad c \neq c_i \text{ for any }i \\
\end{equations}%
where the action of $H = (\handle{c_i~\many{x_i}}{g} \mapsto e_i)_i \medvert x
\mapsto e$ is given by:
\begin{equations}%
H(\key{ret}, v) &=& e[v/x] \\
H(\key{c_j}, \many{v}, u) &=& e_j[\many{v}/\many{x}, u/g] \\
H(\key{c}, \many{v}, u)
  &=& \key{let}~z=c~\many{v}~\key{in}~
        \key{handle}~\force{u}~z~\key{with}~H,
           \quad c \neq c_i\text{ for any }i
\end{equations}%

\begin{mathpar}
\inferrule
  {u \reducesto v}
  {D[u] \reducesto D[v]}

\inferrule
  {d \reducesto e}
  {F[d] \reducesto F[e]}
\end{mathpar}

\caption{Small-step operational semantics for \feff}
\end{figure*}

\section{Related work}
\label{sec:related}


\section{Conclusion and future work}
\label{sec:conclusion}


%% \begin{abstract}
%% This is the text of the abstract.
%% \end{abstract}

%% \category{CR-number}{subcategory}{third-level}

%% \terms
%% term1, term2

%% \keys
%% keyword1, keyword2

%% \section{Introduction}

%% The text of the paper begins here.

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{frankly}

% The bibliography should be embedded for final submission.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\end{document}

Rubbish
-------


sig ReadLine
  = peek : Char
  | nom  : 0

sig Abort
  = aborting : 0

if Bool then {X} else {X} -> X
if tt then t else f = t!
if ff then t else f = f!

0 >> Y [] Y


map {X -> Y} (List X)   []   List Y

top-level functions:

       V == forall Z*.V
  P -> C == {P -> C}

Anywhere:

    V == [e]V
   [] == [e]



d e == d ! e




  P [Sig] V == P -> [Sig]V


 

Push sigs inside:

  [[ [Sig]{C} ]] = [[C]] Sig

  [[ <V> ]] Sig          = [ [[Sig]] ] [[V]]
  [[ [Sig']V -> C ]] Sig = [ [[Sig']] ] [[V]] -> [[C]] Sig

Pull sigs outside:

  [[ {C} ]] = [ ((C)) ]{ [[ C ]]}

  [[ [Sig]V -> C )) = [ [[Sig]] ]V -> [[C]]
  [[ [Sig]V ]]      = < [[V]] >

  (( [Sig]V -> C )) = ((C))
  (( [Sig]V ))      = [[Sig]]

foo : Int
foo = 3

map : {X [] Y} (List X) [] List Y


map : forall e X Y.{{[e]X -> <Y>}[e] [e](List X) -> [e](List Y)}[e]



map : forall e X Y.{[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[e]{[e]X -> [e]Y} [e](List X) -> [e](List Y)}
map :              {[ ]{[ ]X -> [ ]Y} [ ](List X) -> [ ](List Y)}
map :              {   {   X ->    Y}    (List X) ->    (List Y)}
map :                  {   X ->    Y}    (List X) ->    (List Y)


map : forall e X Y.[e]{[e]([e]{[e]X -> <Y>}) [e](List X) -> <List Y>}



map :              [e]{[e]{[e]X -> <Y>} [e](List X) -> <List Y>}
map :                 {   {   X -> <Y>}    (List X) -> <List Y>}
map :                     {   X -> <Y>}    (List X) -> <List Y>
map :                     {   X ->  Y }    (List X) ->  List Y

map : {X -> Y} (List X) -> List Y
map f nil        = nil
map f (x :: xs)  = f x :: map f xs


main [Console] List ()

main forall e.[e, Console] {<List ()>}
main          [e, Console] {<List ()>}
main          [   Console] {<List ()>}
main          [   Console]   List ()
main = map ouch ('h' :: ('e' :: ('l' :: ('l' :: ('o' :: nil)))))
